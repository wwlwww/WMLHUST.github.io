<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小本本</title>
  
  <subtitle>学而时习之，不亦说乎</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-25T15:50:31.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>WordGe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式事务常见方案</title>
    <link href="http://yoursite.com/2020/07/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>http://yoursite.com/2020/07/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</id>
    <published>2020-07-25T15:50:31.000Z</published>
    <updated>2020-07-25T15:50:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>分布式事务是个复杂繁琐的问题，如果能够通过调整业务或架构，避免分布式事务，尽量避免。</strong></p><p>下面总结、对比一下常见的分布式事务实现方案：</p><h3 id="1-2PC-XA"><a href="#1-2PC-XA" class="headerlink" title="1. 2PC / XA"></a>1. 2PC / XA</h3><p>XA规范的协议原理即为 2PC。关键点：</p><ol><li>需要一个事务协调器。</li><li>每个实例，分为两个阶段，第一阶段<code>prepare</code>，第二阶段，<code>commit/rollback</code>。   </li></ol><p>存在问题：</p><ol><li>事务协调器，单点故障。故障时，为了保证事务连续，只能等待该协调器重启恢复。</li><li>性能问题，阶段1，锁定资源后，必须要等所有节点返回，然后才能一同进入阶段2。</li><li>如果commit部分成功，将出现数据不一致。此时只能不断重试，直到成功。</li></ol><h3 id="2-3PC"><a href="#2-3PC" class="headerlink" title="2. 3PC"></a>2. 3PC</h3><p>3PC的三个阶段分别是<code>canCommit</code>、<code>preCommit</code>、<code>doCommit</code>。<br>相比两阶段提交：</p><ol><li>多了preCommit一步，实际是把2PC划分得更细。2PC在阶段1时，如果部分成功，则rollback。而在阶段2时，如果部分成功（实际上，每个实例应该保证，一旦收到commit，必定能成功。前提条件检查应放在阶段1做。），则只能不断重试。3PC拆分得更细后，根据不同阶段的超时，执行不同的动作。<br>当然，2PC中，实例也可以在阶段2，等待commit超时后rollback。不能是commit，因为可能阶段1不是全部成功，出于一致性考虑，只能rollback，然后调用方不断重试。<br>3PC分为两个阶段后，超时更好控制。在阶段2等待preCommit超时和2PC中等待commit超时一样，需要rollback。但是如果在阶段3等待doCommit超时，至少能确定canCommit都是成功的，因此可以执行commit。</li><li>相比2PC，增加超时功能，减少对事务协调器的依赖，避免持续阻塞：<ul><li>实例等待preCommit指令时，超时后自动 rollback</li><li>实例等待doCommit指令时，超时后自动 commit</li></ul></li></ol><p>然而，3PC也需要协调者，协调者也需要等待各个实例的回复，这些回复也可能超时。<strong>根源在于，通信信道没有保证，因此两个节点之间，如果超时，无法确定对方是宕机了，还是消息丢失了。所以，此时是成功了，还是失败了呢？</strong></p><h3 id="3-TCC"><a href="#3-TCC" class="headerlink" title="3. TCC"></a>3. TCC</h3><p>TCC (<code>Try - Confirm - Cancel</code>)<br>相比TCC，更偏向应用层一点，比如服务间调用，各阶段之间会穿插一些业务逻辑等。2PC、3PC更像是协调两个数据库实例。比如：一个订单服务需要支付、库存、积分、物流多个服务的状态保持一致。一般使用一些TCC事务框架，框架需要保存事务日志之类的。   </p><ul><li>如果try失败，调用cancel</li><li>如果confirm失败，不停重试confirm</li><li>如果cancel失败，不停重试cancel   </li></ul><p>因此try/confirm/cancel接口需要幂等，因此需要一些事务ID之类的东西，TCC框架可以协助实现。</p><p>参考文章：</p><ul><li>介绍TCC流程，<a href="https://juejin.im/post/5bf201f7f265da610f63528a" target="_blank" rel="noopener">https://juejin.im/post/5bf201f7f265da610f63528a</a></li><li>介绍TCC细节，<a href="https://yemablog.com/posts/tcc-1" target="_blank" rel="noopener">https://yemablog.com/posts/tcc-1</a></li></ul><h3 id="4-消息中间件（实现的是最终一致）"><a href="#4-消息中间件（实现的是最终一致）" class="headerlink" title="4. 消息中间件（实现的是最终一致）"></a>4. 消息中间件（实现的是最终一致）</h3><p>这个没啥特别的，主要是利用消息队列解耦，从而A完成事务后可直接返回，B从MQ中取消息，发生错误则不断尝试。<br><img src="/images/tx-mq.jpg" alt=""></p><p>特别提一下rocketMQ事务消息的实现原理：<br>rocketMQ的消息发送，分为两个阶段：prepare和confirm。<br>当confirm后，broker才会将消息传递给消费方。<br>对于一直未confirm的消息，broker会定期扫描，询问发送方此消息，是发送还是取消。   </p><p>再特别提一下，两个服务之间，最终一致性的关键：<br>持久化中间件（MySQL，消息对列等），配合幂等重试。<br>比如转账，A服务扣了钱，记录进DB。异步调用B服务加钱接口，失败则重试，直到成功。（失败多次后，一般会人工介入）   </p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol><li><a href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/" target="_blank" rel="noopener">https://xiaomi-info.github.io/2020/01/02/distributed-transaction/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;分布式事务是个复杂繁琐的问题，如果能够通过调整业务或架构，避免分布式事务，尽量避免。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面总结、对比一下常见的分布式事务实现方案：&lt;/p&gt;
&lt;h3 id=&quot;1-2PC-XA&quot;&gt;&lt;a href=&quot;#1-2PC-XA&quot; class
      
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="系统原理" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>python多元赋值的一个顺序问题</title>
    <link href="http://yoursite.com/2020/07/12/python%E5%A4%9A%E5%85%83%E8%B5%8B%E5%80%BC%E7%9A%84%E4%B8%80%E4%B8%AA%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/07/12/python%E5%A4%9A%E5%85%83%E8%B5%8B%E5%80%BC%E7%9A%84%E4%B8%80%E4%B8%AA%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/</id>
    <published>2020-07-12T10:50:22.000Z</published>
    <updated>2020-07-12T10:50:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>起因是试验一个python翻转链表的代码，python的变量交换非常方便，比如交换两个元素，可以直接<code>a, b = b, a</code>，因此翻转链表，可以这么写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(head: ListNode)</span> :</span></span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        cur, pre, cur.next = cur.next, cur, pre</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><p>然而，这个代码是错误的。</p><p>经过单步debug，发现在第一次交换发生时，交换的结果就不对。<br>不用怀疑，如果是 <code>a, b, c = b, c, a</code>，那肯定是对的。所以问题出在哪里？不会是python的一个bug吧？<br>追根溯源，直接看下字节码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化链表</span></span><br><span class="line">n0 = ListNode(<span class="number">0</span>)</span><br><span class="line">n1 = ListNode(<span class="number">1</span>)</span><br><span class="line">n2 = ListNode(<span class="number">2</span>)</span><br><span class="line">n3 = ListNode(<span class="number">3</span>)</span><br><span class="line">n0.next = n1</span><br><span class="line">n1.next = n2</span><br><span class="line">n2.next = n3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看交换代码的字节码</span></span><br><span class="line">pre = <span class="literal">None</span></span><br><span class="line">cur = n0</span><br><span class="line">dis.dis(<span class="string">"cur, pre, cur.next = cur.next, cur, pre"</span>)</span><br></pre></td></tr></table></figure><p>输出是   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0-10步，先依次取右值 cur.next, cur, pre，然后倒序</span></span><br><span class="line"> <span class="number">0</span> LOAD_NAME     <span class="number">0</span> (cur)   <span class="comment"># 取cur值，push入栈</span></span><br><span class="line"> <span class="number">2</span> LOAD_ATTR     <span class="number">1</span> (next)  <span class="comment"># 取cur.next，替换栈顶</span></span><br><span class="line"> <span class="number">4</span> LOAD_NAME     <span class="number">0</span> (cur)   <span class="comment"># 取cur值，push入栈</span></span><br><span class="line"> <span class="number">6</span> LOAD_NAME     <span class="number">2</span> (pre)   <span class="comment"># 取pre值，push入栈</span></span><br><span class="line"> <span class="number">8</span> ROT_THREE</span><br><span class="line"><span class="number">10</span> ROT_TWO                 <span class="comment"># ROT_3和ROT_2两步的效果，就是对栈内的3个元素倒序</span></span><br><span class="line">                           <span class="comment"># 目前栈内从顶至底分别为[old_cur_next, old_cur, old_pre]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上步骤没有问题，提前准备好要赋值的数据。</span></span><br><span class="line"><span class="comment"># 接下来，依次赋值左边变量，cur, pre, cur.next</span></span><br><span class="line"><span class="number">12</span> STORE_NAME    <span class="number">0</span> (cur)   <span class="comment"># pop栈顶，赋值给 cur (new_cur = old_cur_next)</span></span><br><span class="line">                           <span class="comment"># 此时栈 [old_cur, old_pre]</span></span><br><span class="line"></span><br><span class="line"><span class="number">14</span> STORE_NAME    <span class="number">2</span> (pre)   <span class="comment"># pop栈顶，赋值给 pre (new_pre = old_cur)</span></span><br><span class="line">                           <span class="comment"># 此时栈 [old_pre]</span></span><br><span class="line"></span><br><span class="line"><span class="number">16</span> LOAD_NAME     <span class="number">0</span> (cur)   <span class="comment"># 取cur值，push入栈</span></span><br><span class="line">                           <span class="comment"># 此时栈 [new_cur, old_pre]</span></span><br><span class="line"></span><br><span class="line"><span class="number">18</span> STORE_ATTR    <span class="number">1</span> (next)  <span class="comment"># 将栈顶元素(也就是cur)的next属性，赋值为栈的第二个元素</span></span><br><span class="line">                           <span class="comment"># new_cur.next = old_pre</span></span><br></pre></td></tr></table></figure><p>关键在于第16步，重新load了一下cur，而此时cur已经在第12步，被赋值为old_cur_next。实际执行的是<code>new_cur.next = old_pre</code>，而我们的目标是<code>old_cur.next = old_pre</code>。因此出现了不一致。</p><p>关键在于 <strong>多元赋值中，左边被赋值的变量是有先后关系的。先改变了cur，那么再给cur.next赋值时，cur就已经是新的cur。因此如果同时需要改变cur、cur.next的值，应该优先赋值cur.next。</strong></p><p>修改后的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(head: ListNode)</span> :</span></span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># cur, pre, cur.next = cur.next, cur, pre</span></span><br><span class="line">        cur.next, pre, cur  = pre, cur, cur.next</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;起因是试验一个python翻转链表的代码，python的变量交换非常方便，比如交换两个元素，可以直接&lt;code&gt;a, b = b, a&lt;/code&gt;，因此翻转链表，可以这么写：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题目思路简结-3</title>
    <link href="http://yoursite.com/2020/06/25/%E5%89%91%E6%8C%87offer%E9%A2%98%E7%9B%AE%E6%80%9D%E8%B7%AF%E7%AE%80%E7%BB%93-3/"/>
    <id>http://yoursite.com/2020/06/25/%E5%89%91%E6%8C%87offer%E9%A2%98%E7%9B%AE%E6%80%9D%E8%B7%AF%E7%AE%80%E7%BB%93-3/</id>
    <published>2020-06-25T01:36:29.000Z</published>
    <updated>2020-06-25T01:36:29.000Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><pre><code>1. [剑指 Offer 50. 第一个只出现一次的字符](#剑指-offer-50-第一个只出现一次的字符)2. [剑指 Offer 51. 数组中的逆序对](#剑指-offer-51-数组中的逆序对)3. [剑指 Offer 52. 两个链表的第一个公共节点](#剑指-offer-52-两个链表的第一个公共节点)4. [剑指 Offer 53 - I. 在排序数组中查找数字 I](#剑指-offer-53---i-在排序数组中查找数字-i)5. [指 Offer 53 - II. 0～n-1中缺失的数字](#指-offer-53---ii-0n-1中缺失的数字)6. [剑指 Offer 54. 二叉搜索树的第k大节点](#剑指-offer-54-二叉搜索树的第k大节点)7. [剑指 Offer 55 - I. 二叉树的深度](#剑指-offer-55---i-二叉树的深度)8. [剑指 Offer 55 - II. 平衡二叉树](#剑指-offer-55---ii-平衡二叉树)9. [剑指 Offer 56 - I. 数组中数字出现的次数](#剑指-offer-56---i-数组中数字出现的次数)10. [剑指 Offer 56 - II. 数组中数字出现的次数 II](#剑指-offer-56---ii-数组中数字出现的次数-ii)11. [剑指 Offer 57 - II. 和为s的连续正数序列](#剑指-offer-57---ii-和为s的连续正数序列)12. [剑指 Offer 58 - I. 翻转单词顺序](#剑指-offer-58---i-翻转单词顺序)13. [剑指 Offer 58 - II. 左旋转字符串](#剑指-offer-58---ii-左旋转字符串)14. [剑指 Offer 59 - I. 滑动窗口的最大值](#剑指-offer-59---i-滑动窗口的最大值)15. [剑指 Offer 59 - II. 队列的最大值](#剑指-offer-59---ii-队列的最大值)16. [剑指 Offer 60. n个骰子的点数](#剑指-offer-60-n个骰子的点数)17. [剑指 Offer 61. 扑克牌中的顺子](#剑指-offer-61-扑克牌中的顺子)18. [剑指 Offer 62. 圆圈中最后剩下的数字](#剑指-offer-62-圆圈中最后剩下的数字)19. [剑指 Offer 63. 股票的最大利润](#剑指-offer-63-股票的最大利润)20. [剑指 Offer 64. 求1+2+…+n](#剑指-offer-64-求12n)21. [剑指 Offer 65. 不用加减乘除做加法](#剑指-offer-65-不用加减乘除做加法)22. [剑指 Offer 66. 构建乘积数组](#剑指-offer-66-构建乘积数组)23. [剑指 Offer 67. 把字符串转换成整数](#剑指-offer-67-把字符串转换成整数)24. [剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](#剑指-offer-68---i-二叉搜索树的最近公共祖先)25. [剑指 Offer 68 - II. 二叉树的最近公共祖先](#剑指-offer-68---ii-二叉树的最近公共祖先)</code></pre><ol><li><a href="#完结散花-">完结散花 <del>~</del></a></li></ol><!-- /TOC --><h2 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符"></a>剑指 Offer 50. 第一个只出现一次的字符</h2><p>遍历字符串，搞个map记录字符出现次数。再次遍历字符串，遇到出现次数为 1 的就返回。</p><h2 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51. 数组中的逆序对"></a>剑指 Offer 51. 数组中的逆序对</h2><p>这题值得hard难度。<br>如果暴力解法，时间复杂度将是O(N^2)。比排序的O(NlogN)还大，那么可否先排序在比较，降低复杂度？<br>比如 [7, 5, 6, 4]   </p><ol><li>先均分为两部分 [7, 5] 和 [6, 4]，分别排序得到，[5, 7] 和 [4, 6]。</li><li>对于5，发现只比4大，说明只有一个[5, 4]，对于7，继续与6比较，而不用继续跟4比较，说明有[7, 4]、[7, 6] 两个。</li><li>继续分别针对[7，5] 和 [6, 4] 重复 <code>均分-&gt;排序-&gt;比较</code> 这个过程。分别只有一个结果[7, 5]和[6, 4]。</li><li>所以最终结果为 5 </li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 比较两个排好序的子数组</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">computePairs</span><span class="params">(arr1: List[int], arr2: List[int])</span> -&gt; int:</span></span><br><span class="line">            <span class="keyword">if</span> len(arr1) == <span class="number">0</span> <span class="keyword">or</span> len(arr2) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            l = <span class="number">0</span></span><br><span class="line">            r = <span class="number">0</span></span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> l&lt;len(arr1) :</span><br><span class="line">                <span class="keyword">while</span> r &lt; len(arr2) <span class="keyword">and</span> arr1[l] &gt; arr2[r]:</span><br><span class="line">                    r += <span class="number">1</span></span><br><span class="line">                res += r</span><br><span class="line">                l+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 划分 &amp; 排序</span></span><br><span class="line">        nums2 = nums.copy()</span><br><span class="line">        left_arr = nums[:len(nums2)//<span class="number">2</span>]</span><br><span class="line">        right_arr = nums[len(nums2)//<span class="number">2</span>:]</span><br><span class="line">        left_arr.sort()</span><br><span class="line">        right_arr.sort()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算本身结果，并递归子数组</span></span><br><span class="line">        <span class="keyword">return</span> computePairs(left_arr, right_arr) \</span><br><span class="line">               + self.reversePairs(nums[:len(nums)//<span class="number">2</span>]) \</span><br><span class="line">               + self.reversePairs(nums[len(nums)//<span class="number">2</span>:])</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a>剑指 Offer 52. 两个链表的第一个公共节点</h2><p>最简单的，先计算长度，然后比较两者的长度差，再利用快慢指针。<br>一个巧妙的办法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA: ListNode, headB: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        c1 = headA</span><br><span class="line">        c2 = headB</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. 最终c1和c2走的长度是相等的，LA + LB</span></span><br><span class="line">        <span class="comment"># 2. 如果不存在相交，c1走到B的结尾时会被赋值为None，此时c2也恰好走到A的结尾被赋值为None，刚好两者相等，跳出循环</span></span><br><span class="line">        <span class="keyword">while</span> c1 != c2:</span><br><span class="line">            c1 = c1.next <span class="keyword">if</span> c1 <span class="keyword">else</span> headB</span><br><span class="line">            c2 = c2.next <span class="keyword">if</span> c2 <span class="keyword">else</span> headA</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c1</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a>剑指 Offer 53 - I. 在排序数组中查找数字 I</h2><p>先二分查找位置，再左右扩展。复杂度最差 O(N)，平均 O(logN) + O(M)。M为结果个数。如果M==N，则平均复杂度退化为 O(logN) + O(N)<br>再优化一下，可以先查左边界，再查右边界。就是 O(logN) 的复杂度，避免了最差O(N)的复杂度。   </p><p>都比暴力解法强吧 [doge][doge] </p><h2 id="指-Offer-53-II-0～n-1中缺失的数字"><a href="#指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="指 Offer 53 - II. 0～n-1中缺失的数字"></a>指 Offer 53 - II. 0～n-1中缺失的数字</h2><p>规律是：在缺失数左侧，每个数与其索引是相等的；在缺失数右侧，每个数 &gt; 其索引。因此可利用二分查找缺失数的位置。</p><h2 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a>剑指 Offer 54. 二叉搜索树的第k大节点</h2><p>按 <code>右子树 -&gt; 根 -&gt; 左子树</code> 的顺序遍历，使用全局变量记录还需遍历多少个节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 返回</span></span><br><span class="line">        <span class="comment"># 1. 是否找到</span></span><br><span class="line">        <span class="comment"># 2. 对应的值</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(r: TreeNode)</span> -&gt; (bool, int):</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> r <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span>, <span class="number">0</span></span><br><span class="line">            <span class="comment"># 遍历右子树</span></span><br><span class="line">            found, val = dfs(r.right)</span><br><span class="line">            <span class="keyword">if</span> found:</span><br><span class="line">                <span class="keyword">return</span> found, val</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 遍历根</span></span><br><span class="line">            <span class="keyword">if</span> self.nk == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span>, r.val</span><br><span class="line">            self.nk -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 遍历左子树</span></span><br><span class="line">            <span class="keyword">return</span> dfs(r.left)</span><br><span class="line"></span><br><span class="line">        self.nk = k</span><br><span class="line">        _, v = dfs(root)</span><br><span class="line">        <span class="keyword">return</span> v</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-55-I-二叉树的深度"><a href="#剑指-Offer-55-I-二叉树的深度" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度"></a>剑指 Offer 55 - I. 二叉树的深度</h2><p>DFS，<code>Depth(root) = 1 + max(Depth(root.left), Depth(root.right))</code></p><h2 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a>剑指 Offer 55 - II. 平衡二叉树</h2><ol><li>解法一：计算并检查每一个节点左右子树的深度，但是这样做会有很多的重复计算。</li><li>解法二：自底向上，同时记录当前子树的深度，从而在计算父节点的深度时，避免重复计算。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -1 表示非平衡，直接返回</span></span><br><span class="line"><span class="comment"># &gt;=0 表示树的深度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">valid</span><span class="params">(root: TreeNode)</span> -&gt; (int):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    left = valid(root.left)</span><br><span class="line">    <span class="keyword">if</span> left == <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    right = valid(root.right)</span><br><span class="line">    <span class="keyword">if</span> right == <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> abs(left - right) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max(left, right) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> valid(root) != <span class="number">-1</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数"></a>剑指 Offer 56 - I. 数组中数字出现的次数</h2><ol><li>如果一个数组中，只有一个数字出现了一次，其他数字都出现了两次，那么可以通过对所有数字进行xor操作，最后得到的就是该数</li><li>如果有两个数字a, b出现了一次，可以想办法将这两个数字划分到两个子数组，这两个子数组除下a, b外，其他都出现了两次，则可直接根据上述规律，xor遍历一遍得到a, b<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumbers</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        xor_res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> nums:</span><br><span class="line">            xor_res = xor_res ^ v</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找xor_res为1的那一位</span></span><br><span class="line">        <span class="comment"># 也就是res1 和 res2 不同的那一位</span></span><br><span class="line">        div = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (xor_res &amp; div) == <span class="number">0</span>:</span><br><span class="line">            div = div &lt;&lt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        xor1 = <span class="number">0</span></span><br><span class="line">        xor2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> v &amp; div == <span class="number">0</span>:</span><br><span class="line">                xor1 = xor1 ^ v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                xor2 = xor2 ^ v</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [xor1, xor2]</span><br></pre></td></tr></table></figure></li></ol><h2 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a>剑指 Offer 56 - II. 数组中数字出现的次数 II</h2><ol><li>解法一：遍历统计每个bit 1 出现的次数，最后对 3 取模即可。</li><li>解法二：还有个位运算的解，感觉没必要这么取巧。</li></ol><h2 id="剑指-Offer-57-II-和为s的连续正数序列"><a href="#剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为s的连续正数序列"></a>剑指 Offer 57 - II. 和为s的连续正数序列</h2><p>滑动窗口，<code>[i, j]</code>表示连续子数组的两端，临时sum &lt;&gt; s，j右移扩大窗口，否则 i 左移缩小窗口。</p><h2 id="剑指-Offer-58-I-翻转单词顺序"><a href="#剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="剑指 Offer 58 - I. 翻转单词顺序"></a>剑指 Offer 58 - I. 翻转单词顺序</h2><p>split一下，然后倒序数组，最后拼接。</p><h2 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a>剑指 Offer 58 - II. 左旋转字符串</h2><p>切片操作，不做赘述。</p><h2 id="剑指-Offer-59-I-滑动窗口的最大值"><a href="#剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a>剑指 Offer 59 - I. 滑动窗口的最大值</h2><p>这题标记为 easy 过分了。<br>暴力解法就不说了，时间复杂度是 <code>O(k*N)</code>。<br>可以优化一下，使用单调减的辅助队列（类似单调栈），来减少求每个窗口最大值时的遍历情况。复杂度为O(N)，因为辅助队列里的每个数，平均跟新进入队列的数，比较1次。（因为要么直接加入队列，要么，删掉队尾比它小元素，加入队列），被删掉的元素只会被比较 1 次。<br>考虑极端情况，每个数都会加入辅助队列（原数组是递减的），则每次仍只需比较队尾元素和新加入元素 1 次。因此比较了 2N 次<br>PS：单调栈和单调队列，是一个非常有帮助的思路。</p><h2 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a>剑指 Offer 59 - II. 队列的最大值</h2><p>类似 <a href="#剑指-offer-30-包含min函数的栈">剑指 Offer 30. 包含min函数的栈</a>，同样使用单调减的辅助队列。这题也可以称为”包含max函数的队列“。</p><h2 id="剑指-Offer-60-n个骰子的点数"><a href="#剑指-Offer-60-n个骰子的点数" class="headerlink" title="剑指 Offer 60. n个骰子的点数"></a>剑指 Offer 60. n个骰子的点数</h2><p>这个题目描述得实在不好理解。</p><blockquote><p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p></blockquote><p>不过，写到这里，我发现用文字去描述一个算法思想，确实不太容易。<br>至于这题，举个栗子，比如两个骰子，那么依次输出，抛出骰子的和为 2、3、4、5、6 …的概率。</p><p>首先可知，有 n 个骰子，那么结果范围为 [n, 6*n]，那么利用动态规划思想：</p><ol><li>划分子问题：使用n个骰子抛出 x 的概率，等于使用一个骰子抛出 a 的概率 乘以 n-1 个骰子，抛出 x-a 的概率。一个骰子抛出各个值的概率自然是 1/6</li><li>状态转移公式：dp(n, x) = 1/6 * dp(n, x-a), 其中 a in [1, 6]</li><li>边界条件：dp(1, a) = 1/6，其中 a in [1, 6]</li></ol><h2 id="剑指-Offer-61-扑克牌中的顺子"><a href="#剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子"></a>剑指 Offer 61. 扑克牌中的顺子</h2><p>除下0之外，数组不能重复。同时计算数组的最小值、最大值。（除 0 以外）<br>判断 <code>max_val - min_val</code> 是否 &lt;= 4。 </p><h2 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字"></a>剑指 Offer 62. 圆圈中最后剩下的数字</h2><p>约瑟夫环，这特么竟然标记为<strong>简单！！！</strong> 说是<code>hard</code>真不算过分。<br>因为输出是最后剩下的数字，也正好是其下标。<br>约瑟夫环的关键在于递推公式:    </p><blockquote><p><code>F(N, M) = (F(N-1, M) + M) % N</code>   </p></blockquote><p>其中，<code>F(N,M)</code>表示 N 个人时，某未被删除的数字的下标。<br>假设 <code>F(N,M) = y</code>，在经过一次删除操作后，y的下标变为了 <code>(y-M)%(N-1)</code>，即 F(N-1, M)，设为 x。<br>（因为 N 个数时，删除 M，会从第 M+1 处重新从 0 计算下标。被删除的 M 处于新数组的队尾，因此不会因为空洞之类的原因，影响新的下标计算。）<br>根据   </p><blockquote><p><code>(y-M)%(N-1)=x</code>   </p></blockquote><p>可推得：</p><blockquote><p> <code>y = (x + M) % N</code>   </p></blockquote><p>其实也好理解，相当于删除的逆过程，x左移M个位置，然后对N取余。</p><p>已知，F(1, M) = 0，因为1个人的时候，剩下数字的下标就是 0，那么可以递推出 F(1, M)，F(2, M) 直到 F(N, M)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastRemaining</span><span class="params">(self, n: int, m: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (m + self.lastRemaining(n<span class="number">-1</span>, m)) % n</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a>剑指 Offer 63. 股票的最大利润</h2><p>这个显然算 easy，却标记为 middle。不再啰嗦。</p><h2 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a>剑指 Offer 64. 求1+2+…+n</h2><p>这个妙在，利用 and / or 操作的执行顺序。已知：</p><blockquote><p>A and B，如果 A 为false，则 B 不会再执行<br>  A or B，如果 A 为true，则 B 不会再执行</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNums</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(n: int)</span>:</span></span><br><span class="line">            _ = n != <span class="number">1</span> <span class="keyword">and</span> self.sumNums(n - <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># _ = n == 1 or self.sumNums(n - 1)</span></span><br><span class="line">            self.res += n</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        sum(n)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-65-不用加减乘除做加法"><a href="#剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法"></a>剑指 Offer 65. 不用加减乘除做加法</h2><p>这个特么又标为easy就离谱，里面的细节一点不少。<br>两个数的相加，在二进制上可以表现为两部分：   </p><ol><li>直接相加，忽略进位：s1 = a ^ b，相同为0，不同为1 </li><li>进位部分：s2 = (a &amp; b) &lt;&lt; 1，同为1的位，要向左进一位</li><li>两部分相加：sum = s1 + s2</li></ol><h2 id="剑指-Offer-66-构建乘积数组"><a href="#剑指-Offer-66-构建乘积数组" class="headerlink" title="剑指 Offer 66. 构建乘积数组"></a>剑指 Offer 66. 构建乘积数组</h2><p>使用两个辅助数组，分别计算从左到右，以及从右至左的乘积。<br>再优化一下，可以只使用一个辅助数组。</p><h2 id="剑指-Offer-67-把字符串转换成整数"><a href="#剑指-Offer-67-把字符串转换成整数" class="headerlink" title="剑指 Offer 67. 把字符串转换成整数"></a>剑指 Offer 67. 把字符串转换成整数</h2><p>难点在于检查中间结果是否溢出的条件，两种情况：</p><ol><li><code>res &gt; INT_MAX // 10</code>，此时 res * 10，肯定溢出了   </li><li><code>res == INT_MAX // 10 and cur_num &gt; 7</code>，因为INT_MAX = 2147483647，如果 res 是正数，显然越界；如果 res 是负数，INT_MIN = -2147483648，所以满足这个条件的，只有 INT_MIN 本身。</li></ol><h2 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a>剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</h2><p>先分析下问题：</p><ol><li>如果 p == root 或 q == root，那么 root 本身就是最近公共祖先</li><li>如果 p &lt; root &lt; q，那root一定是最近公共祖先</li><li>如果不满足 1，那么p和q 一定同时在 root 的左子树或右子树   </li></ol><p>上述root可能是某棵子树的根节点。</p><h2 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a>剑指 Offer 68 - II. 二叉树的最近公共祖先</h2><p>先分析下问题：   </p><ol><li>这是一棵普通二叉树，非搜索二叉树，各节点是无序的</li><li>最近公共祖先的定义不变，对于某节点来说，p/q 分别位于其左右子树；或其为p或q，并且q或p在其子树上；该节点就是最近公共祖先。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: TreeNode, p: TreeNode, q: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 你可能有疑问，不用确定另一个在不再它的子树里吗？无需确定</span></span><br><span class="line">        <span class="comment"># 假如root=p，若q在其子树里，root即为最近公共祖先；</span></span><br><span class="line">        <span class="comment"># 若q不在其子树里，那一定在别的子树里，此时会有left_res和right_res都不为None的时候，也就会返回对应的root</span></span><br><span class="line">        <span class="keyword">if</span> root.val == p.val <span class="keyword">or</span> root.val == q.val:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        left_res = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right_res = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="comment"># p, q分别位于root的左右子树，root本身就是解</span></span><br><span class="line">        <span class="keyword">if</span> left_res <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> right_res <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 到这里，left_res 和 right_res 一个为None，一个不为None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 情况1：某子树root==p或q，因此返回了自己，此时最近公共祖先，就是该子树的root。</span></span><br><span class="line">        <span class="comment"># 就是left_res或right_res中不为空的那个。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 情况2：某棵子树上发现了最近公共祖先，将其传递至最上层</span></span><br><span class="line">        <span class="keyword">return</span> left_res <span class="keyword">if</span> left_res <span class="keyword">else</span> right_res</span><br></pre></td></tr></table></figure><h1 id="完结散花"><a href="#完结散花" class="headerlink" title="完结散花 ~"></a>完结散花 <del>~</del></h1><p><img src="/images/jian_zhi_offer.jpg" alt="abc"></p>]]></content>
    
    <summary type="html">
    
      剑指offer 51-75 题，思路简结
    
    </summary>
    
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题目思路简结-2</title>
    <link href="http://yoursite.com/2020/06/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E7%9B%AE%E6%80%9D%E8%B7%AF%E7%AE%80%E7%BB%93-2/"/>
    <id>http://yoursite.com/2020/06/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E7%9B%AE%E6%80%9D%E8%B7%AF%E7%AE%80%E7%BB%93-2/</id>
    <published>2020-06-22T13:43:53.000Z</published>
    <updated>2020-06-22T13:43:53.000Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ol><li><a href="#剑指-offer-26-树的子结构">剑指 Offer 26. 树的子结构</a></li><li><a href="#剑指-offer-27-二叉树的镜像">剑指 Offer 27. 二叉树的镜像</a></li><li><a href="#剑指-offer-28-对称的二叉树">剑指 Offer 28. 对称的二叉树</a></li><li><a href="#剑指-offer-29-顺时针打印矩阵">剑指 Offer 29. 顺时针打印矩阵</a></li><li><a href="#剑指-offer-30-包含min函数的栈">剑指 Offer 30. 包含min函数的栈</a></li><li><a href="#剑指-offer-31-栈的压入弹出序列">剑指 Offer 31. 栈的压入、弹出序列</a></li><li><a href="#剑指-offer-32---i-从上到下打印二叉树">剑指 Offer 32 - I. 从上到下打印二叉树</a></li><li><a href="#剑指-offer-32---ii-从上到下打印二叉树-ii">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></li><li><a href="#剑指-offer-32---iii-从上到下打印二叉树-iii">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></li><li><a href="#剑指-offer-33-二叉搜索树的后序遍历序列">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></li><li><a href="#剑指-offer-34-二叉树中和为某一值的路径">剑指 Offer 34. 二叉树中和为某一值的路径</a></li><li><a href="#剑指-offer-35-复杂链表的复制">剑指 Offer 35. 复杂链表的复制</a></li><li><a href="#剑指-offer-36-二叉搜索树与双向链表">剑指 Offer 36. 二叉搜索树与双向链表</a></li><li><a href="#剑指-offer-37-序列化二叉树">剑指 Offer 37. 序列化二叉树</a></li><li><a href="#剑指-offer-38-字符串的排列">剑指 Offer 38. 字符串的排列</a></li><li><a href="#剑指-offer-39-数组中出现次数超过一半的数字">剑指 Offer 39. 数组中出现次数超过一半的数字</a></li><li><a href="#剑指-offer-40-最小的k个数">剑指 Offer 40. 最小的k个数</a></li><li><a href="#剑指-offer-41-数据流中的中位数">剑指 Offer 41. 数据流中的中位数</a></li><li><a href="#剑指-offer-42-连续子数组的最大和">剑指 Offer 42. 连续子数组的最大和</a></li><li><a href="#剑指-offer-43-1n整数中1出现的次数">剑指 Offer 43. 1～n整数中1出现的次数</a></li><li><a href="#剑指-offer-44-数字序列中某一位的数字">剑指 Offer 44. 数字序列中某一位的数字</a></li><li><a href="#剑指-offer-45-把数组排成最小的数">剑指 Offer 45. 把数组排成最小的数</a></li><li><a href="#剑指-offer-46-把数字翻译成字符串">剑指 Offer 46. 把数字翻译成字符串</a></li><li><a href="#剑指-offer-47-礼物的最大价值">剑指 Offer 47. 礼物的最大价值</a></li><li><a href="#剑指-offer-48-最长不含重复字符的子字符串">剑指 Offer 48. 最长不含重复字符的子字符串</a></li><li><a href="#剑指-offer-49-丑数">剑指 Offer 49. 丑数</a></li></ol><!-- /TOC --><h2 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a>剑指 Offer 26. 树的子结构</h2><p>DFS判断各个子树，是否满足子树条件即可。<br><strong>树的结构，天生适合递归。</strong></p><h2 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a>剑指 Offer 27. 二叉树的镜像</h2><p>递归交换左右子树的左右节点。</p><h2 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a>剑指 Offer 28. 对称的二叉树</h2><p>递归判断左右子树的左右节点。</p><h2 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a>剑指 Offer 29. 顺时针打印矩阵</h2><p>像洋葱一样，一层一层剥离打印。注意一些特殊情况，比如矩阵只有一行、一列的情况</p><h2 id="剑指-Offer-30-包含min函数的栈"><a href="#剑指-Offer-30-包含min函数的栈" class="headerlink" title="剑指 Offer 30. 包含min函数的栈"></a>剑指 Offer 30. 包含min函数的栈</h2><p>关键在于min的复杂度要求O(1)。这里需要用一个单调递减的栈，辅助实现。<br><strong>单调栈、单调队列在处理一些栈、队列最大值、最小值上很有用。</strong></p><h2 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a>剑指 Offer 31. 栈的压入、弹出序列</h2><p>用一个栈去模拟压入、弹出过程，每当pop[0]==stack[-1]时，stack就弹出。<br>如果pushed进栈完后，stack里还有数，则说明序列不对。</p><h2 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a>剑指 Offer 32 - I. 从上到下打印二叉树</h2><p>类似BFS，使用一个队列保存当前level的节点，之后依次遍历。   </p><h2 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a>剑指 Offer 32 - II. 从上到下打印二叉树 II</h2><p>类似 <a href="#剑指-offer-32---i-从上到下打印二叉树">剑指 Offer 32 - I. 从上到下打印二叉树</a>，每层的结果单独保存即可。</p><h2 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a>剑指 Offer 32 - III. 从上到下打印二叉树 III</h2><p>类似 <a href="#剑指-offer-32---i-从上到下打印二叉树">剑指 Offer 32 - I. 从上到下打印二叉树</a>，每层的结果单独保存即可。使用一个flag来判断顺序还是逆序。</p><h2 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a>剑指 Offer 33. 二叉搜索树的后序遍历序列</h2><p>根据root节点，划分左右子树，递归判对即可。</p><h2 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径"></a>剑指 Offer 34. 二叉树中和为某一值的路径</h2><p>递归DFS</p><h2 id="剑指-Offer-35-复杂链表的复制"><a href="#剑指-Offer-35-复杂链表的复制" class="headerlink" title="剑指 Offer 35. 复杂链表的复制"></a>剑指 Offer 35. 复杂链表的复制</h2><p>这题有意思，难得见到一个有意思的链表类的题。思路步骤：   </p><ol><li>复制：对每个节点都复制一个节点，并添加在其后面</li><li>拆分：对复制后的链表进行拆分，由于已知每个节点后面跟的，都是其复制节点，因此只需将复制节点的指向，也指向对应节点的复制节点，即可。</li></ol><h2 id="剑指-Offer-36-二叉搜索树与双向链表"><a href="#剑指-Offer-36-二叉搜索树与双向链表" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表"></a>剑指 Offer 36. 二叉搜索树与双向链表</h2><p>对二叉搜索树模拟中序遍历，用一个指针记录遍历过程中的pre节点，最后将首尾相连，即可。</p><h2 id="剑指-Offer-37-序列化二叉树"><a href="#剑指-Offer-37-序列化二叉树" class="headerlink" title="剑指 Offer 37. 序列化二叉树"></a>剑指 Offer 37. 序列化二叉树</h2><p>这题标记为hard，但实际上应该只算得上middle。   </p><ol><li>序列化：类似层次遍历，与 <a href="#剑指-offer-32---i-从上到下打印二叉树">剑指 Offer 32 - I. 从上到下打印二叉树</a> 相似。   </li><li>反序列化：还是模拟层次遍历的过程</li></ol><h2 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a>剑指 Offer 38. 字符串的排列</h2><p>这种排列组合、枚举类题，都可以用回溯思想来解决。和DFS类似，其实DFS是回溯思想在树、图之类的特殊场景里的一种表现。同DFS，回溯的常见实现方式也是递归。<br><strong>递归的时候，要小心大量的重复计算。（动态规划的递归实现中也存在）</strong> 通常要进行剪枝操作。因此也和动态规划的实现类似，可以使用备忘录法，或自底向上法。自底向上法效率最高，因为常常可以用循环迭代方式实现，减少递归调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 递归回溯，执行时间700ms</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation1</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">''</span>]</span><br><span class="line"></span><br><span class="line">        res = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s)):</span><br><span class="line">            child_res = self.permutation1(s[:i] + s[i + <span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> child_res:</span><br><span class="line">                res.add(s[i] + v)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list(res)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 备忘录，执行时间120ms</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation2</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        seen = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">perm</span><span class="params">(s2)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(s2) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> [<span class="string">''</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> s2 <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">return</span> seen[s2]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 递归过程不变</span></span><br><span class="line">            res = set()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s2)):</span><br><span class="line">                child_res = perm(s2[:i] + s2[i + <span class="number">1</span>:])</span><br><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> child_res:</span><br><span class="line">                    res.add(s2[i:i + <span class="number">1</span>] + v)</span><br><span class="line"></span><br><span class="line">            seen[s2] = list(res)</span><br><span class="line">            <span class="keyword">return</span> list(res)</span><br><span class="line"></span><br><span class="line">        sorted_s = <span class="string">''</span>.join(sorted(s))</span><br><span class="line">        <span class="keyword">return</span> perm(sorted_s)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自底向上，执行时间80ms</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation3</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">''</span>]</span><br><span class="line"></span><br><span class="line">        res = set(s[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s[<span class="number">1</span>:]:</span><br><span class="line">            new_set = set()</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> res:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(item)+<span class="number">1</span>):</span><br><span class="line">                    new_item = item[<span class="number">0</span>:i] + c + item[i:]</span><br><span class="line">                    new_set.add(new_item)</span><br><span class="line">            res = new_set</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list(res)</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a>剑指 Offer 39. 数组中出现次数超过一半的数字</h2><p>遍历一遍数组，记录一个数，及其出现次数。</p><h2 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a>剑指 Offer 40. 最小的k个数</h2><p>经典题目，两种解法：</p><ol><li>利用容量为K的大顶堆，遍历一遍即可，比堆顶元素小的入堆，容量超过K时出堆</li><li>利用快排的二分思路，每次可以排除一批不满足条件的数，从而快速缩小查找范围   </li></ol><p>解法的关键思想在于，找最小的k个数，但是这k个数互相是不必排序的，因此尽力减少这部分排序操作。堆就减少了内部各个元素互相排序的操作。同样快排的二分思想，也可以一下子找到最大的m个数，m取决于所选的pivot。但是这m个数只需跟pivot比较，相互之间无需比较。</p><h2 id="剑指-Offer-41-数据流中的中位数"><a href="#剑指-Offer-41-数据流中的中位数" class="headerlink" title="剑指 Offer 41. 数据流中的中位数"></a>剑指 Offer 41. 数据流中的中位数</h2><p>这个有点妙。   </p><ol><li>使用两个堆，一个使用小顶堆，保存较大的一半数字；一个使用大顶堆，保存较小的一半数字。同时保持两个堆的元素数量相对平衡 <code>0 &lt;= (大堆-小堆) &lt; 1</code>。此时两个堆的堆顶元素，就是数据流中间的两个数。</li><li>在push时，将其和堆顶元素比较选一个堆加入。如果加入后，两个堆失去平衡，则进行调整</li><li>取中位数时，根据两个堆元素数是否相等可知，一共有奇数或偶数个数字。从而根据堆顶元素，计算中位数。</li></ol><h2 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a>剑指 Offer 42. 连续子数组的最大和</h2><p>对于每一个元素，有两个选择，与前一个数字组成子数组，或重新开始计算子数组。<br>记录遍历过程中的最大值。</p><h2 id="剑指-Offer-43-1～n整数中1出现的次数"><a href="#剑指-Offer-43-1～n整数中1出现的次数" class="headerlink" title="剑指 Offer 43. 1～n整数中1出现的次数"></a>剑指 Offer 43. 1～n整数中1出现的次数</h2><p>按个位、十位、百位…考虑，比如：输入314，分析过程如下   </p><ol><li>个位4，&gt;1，高位为31，受此影响，有 32 * 1 = 32 种可能</li><li>十位1，=1，高位为3，低位为4，受此影响，有 3*10 + 5 = 35 种可能</li><li>百位3，&gt;1，高位为0，受此影响，有 1*100 = 100 种可能   </li></ol><p>因此一共 32 + 35 + 100 = 167个。关键在于梳理清各种情况下1的个数。<br>比如十位为1时，那么有01x/11x/21x，以及310~314，这么多种，也就是 3*10+5 = 35种。<br>对于百位，当百位为1时，有1xx这么多种情况，所以就是 1 * 100种。</p><h2 id="剑指-Offer-44-数字序列中某一位的数字"><a href="#剑指-Offer-44-数字序列中某一位的数字" class="headerlink" title="剑指 Offer 44. 数字序列中某一位的数字"></a>剑指 Offer 44. 数字序列中某一位的数字</h2><p>和 <a href="#剑指-offer-43-1n整数中1出现的次数">剑指 Offer 43. 1～n整数中1出现的次数</a> 类似，关键在于找规律。可以发现:<br>忽略0<br>数字为1位的，从 1 开始，一共 9 个，1 - 9<br>数字为2位的，从 10 开始，一共 90 个，10 - 99<br>数字为3位的，从 100 开始，一共 900 个，100 - 999<br>…<br>依此可确定，第n位所在的区间，在取模可得到具体是哪个数字。大致思想如上，实现细节不再赘述。</p><h2 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a>剑指 Offer 45. 把数组排成最小的数</h2><p>一个取巧的办法，对数组进行自定义排序，从小到大。对于a、b两数的比较规则是，如果ab&gt;ba，则a&gt;b，否则a&lt;b。   </p><h2 id="剑指-Offer-46-把数字翻译成字符串"><a href="#剑指-Offer-46-把数字翻译成字符串" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串"></a>剑指 Offer 46. 把数字翻译成字符串</h2><p>按动态规划的方式比较好理解：</p><ol><li>划分子问题：每一位数字，既可以单独表示一个字母，也可以与后面数字组合，共同表示一个字母，如果&lt;26的话。</li><li>状态转移公式：F(s) = F(s[1:]) + F(s[2:])</li><li>边界条件：len(s)&lt;=1时，F(s) = 1; 为什么 s 是空字符串时，F(s)也=1呢，s为空字符串，表示刚好划分完，仅此一种。比如12，F(12) = F(2) + F(“”)，F(“”)表示，12作为一个整体解释。</li></ol><h2 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a>剑指 Offer 47. 礼物的最大价值</h2><p>很基础的动态规划题：<br>按动态规划的方式比较好理解：</p><ol><li>划分子问题：每一个格子可以分为，从上边格子和左边格子过来两种情况</li><li>状态转移公式：dp[i][j] = max(dp[i-1][j]+grid[i][j], dp[i][j-1]+grid[i][j])</li><li>边界条件：第一行和第一列，单独处理   </li></ol><p>另外可以发现，dp[i][j]只和上一行有关，因此为了降低空间复杂度，可以只用一行空间即可。对 M*N 的格子，空间复杂度可以从 O(M * N) 降低至 O(M) 或 O(N)</p><h2 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a>剑指 Offer 48. 最长不含重复字符的子字符串</h2><p>使用两个指针 i, j，分别表示起始和结束。同时记录、更新某字符上次出现的位置。<br>如果 j 指向的当前字符，上次出现的位置 k &gt; i，表示重复出现，则 i 更新为 k + 1。此时得到一个最长不重复子字符串，长度为 j-i。</p><h2 id="剑指-Offer-49-丑数"><a href="#剑指-Offer-49-丑数" class="headerlink" title="剑指 Offer 49. 丑数"></a>剑指 Offer 49. 丑数</h2><p>下一个丑数为，当前丑数序列 * 2、3、5，得到的丑数中，最小的那个。<br>为了避免重复计算，可以使用三个数，分别记录上一个乘以2、3、5后，就大于最新丑数的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp = [<span class="number">0</span>] * n</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        a, b, c = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 计算下一个丑数</span></span><br><span class="line">            aN, bN, cN = dp[a] * <span class="number">2</span>, dp[b] * <span class="number">3</span>, dp[c] * <span class="number">5</span></span><br><span class="line">            <span class="comment"># 选最小的</span></span><br><span class="line">            next = min(aN, bN, cN)</span><br><span class="line">            dp[i] = next</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> next == aN:</span><br><span class="line">                a += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> next == bN:</span><br><span class="line">                b += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> next == cN:</span><br><span class="line">                c += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      剑指offer 24-50 题，思路简结
    
    </summary>
    
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题目思路简结-1</title>
    <link href="http://yoursite.com/2020/06/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E7%9B%AE%E6%80%9D%E8%B7%AF%E7%AE%80%E7%BB%93-1/"/>
    <id>http://yoursite.com/2020/06/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E7%9B%AE%E6%80%9D%E8%B7%AF%E7%AE%80%E7%BB%93-1/</id>
    <published>2020-06-22T06:54:13.000Z</published>
    <updated>2020-06-22T06:54:13.000Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ol><li><a href="#剑指-offer-03数组中重复的数字">剑指 Offer 03.数组中重复的数字</a></li><li><a href="#剑指-offer-04-二维数组中的查找">剑指 Offer 04. 二维数组中的查找</a></li><li><a href="#剑指-offer-05-替换空格">剑指 Offer 05. 替换空格</a></li><li><a href="#剑指-offer-06-从尾到头打印链表">剑指 Offer 06. 从尾到头打印链表</a></li><li><a href="#剑指-offer-07-重建二叉树">剑指 Offer 07. 重建二叉树</a></li><li><a href="#剑指-offer-09-用两个栈实现队列">剑指 Offer 09. 用两个栈实现队列</a></li><li><a href="#剑指-offer-10--i-斐波那契数列">剑指 Offer 10- I. 斐波那契数列</a></li><li><a href="#剑指-offer-10--ii-青蛙跳台阶问题">剑指 Offer 10- II. 青蛙跳台阶问题</a></li><li><a href="#剑指-offer-11-旋转数组的最小数字">剑指 Offer 11. 旋转数组的最小数字</a></li><li><a href="#剑指-offer-12-矩阵中的路径">剑指 Offer 12. 矩阵中的路径</a></li><li><a href="#剑指-offer-13-机器人的运动范围">剑指 Offer 13. 机器人的运动范围</a></li><li><a href="#剑指-offer-14--i-剪绳子">剑指 Offer 14- I. 剪绳子</a></li><li><a href="#剑指-offer-14--ii-剪绳子-ii">剑指 Offer 14- II. 剪绳子 II</a></li><li><a href="#剑指-offer-15-二进制中1的个数">剑指 Offer 15. 二进制中1的个数</a></li><li><a href="#剑指-offer-16-数值的整数次方">剑指 Offer 16. 数值的整数次方</a></li><li><a href="#剑指-offer-17-打印从1到最大的n位数">剑指 Offer 17. 打印从1到最大的n位数</a></li><li><a href="#剑指-offer-18-删除链表的节点">剑指 Offer 18. 删除链表的节点</a></li><li><a href="#剑指-offer-19-正则表达式匹配">剑指 Offer 19. 正则表达式匹配</a></li><li><a href="#剑指-offer-20-表示数值的字符串">剑指 Offer 20. 表示数值的字符串</a></li><li><a href="#剑指-offer-21-调整数组顺序使奇数位于偶数前面">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></li><li><a href="#剑指-offer-22-链表中倒数第k个节点">剑指 Offer 22. 链表中倒数第k个节点</a></li><li><a href="#剑指-offer-24-反转链表">剑指 Offer 24. 反转链表</a></li><li><a href="#剑指-offer-25-合并两个排序的链表">剑指 Offer 25. 合并两个排序的链表</a></li></ol><!-- /TOC --><h2 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03.数组中重复的数字"></a>剑指 Offer 03.数组中重复的数字</h2><p>直接使用hash即可，高级一点的使用bitmap也可</p><h2 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a>剑指 Offer 04. 二维数组中的查找</h2><p>关键在于，利用规律缩小查找范围。   </p><ol><li>如果target &lt; 当前的数，那么它就不可能在target同一行的左边</li><li>每一列都按照从上到下递增的顺序排序：那么如果target &gt; 当前的数，那么它就不可能在target同一列的上面  </li></ol><p>从右上角开始找，一点一点缩小范围。</p><h2 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h2><ol><li>如果用python/java/golang之类的，可以直接拼接字符串。动态分配内存。   </li><li>如果用c/c++，就需要预分配内存，因此需要先遍历一遍，计算有多少个空格，从而计算结果字符串所需内存大小。</li></ol><h2 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a>剑指 Offer 06. 从尾到头打印链表</h2><ol><li>解法一：先遍历，再对结果数组反转</li><li>解法二：使用栈暂存节点，然后弹出栈 </li></ol><h2 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a>剑指 Offer 07. 重建二叉树</h2><p>关键点：</p><ol><li>前序遍历的第一个节点，是当前节点的root；但是没法区分剩余节点，哪些是左、右子树</li><li>根据root，可以把中序遍历，分为左右子树两部分；借此得知左右子树的节点数量，也就能把前序遍历剩余节点分开</li><li>对前序遍历拆分的左右子树，递归求解</li></ol><h2 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a>剑指 Offer 09. 用两个栈实现队列</h2><p>关键点：</p><ol><li>两个栈，一个是input栈，一个是output栈，分别只负责input和output</li><li>output没了，就从input里转移到output   </li></ol><p>时间复杂度，O(1)；空间复杂度，O(n)</p><h2 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a>剑指 Offer 10- I. 斐波那契数列</h2><p>递归、迭代解法，不再赘述。<br>值得一提的是，对于递归类题目，有两个关键点：</p><ol><li>递归子问题</li><li>递归终止条件，这个不能忘   </li></ol><p>尤其是二叉树类的问题，天生合适递归。把一个二叉树的问题，转换为，分别针对左右子树的两个子问题。</p><h2 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a>剑指 Offer 10- II. 青蛙跳台阶问题</h2><p>同 <a href="#剑指-offer-10--i-斐波那契数列">剑指 Offer 10- I. 斐波那契数列</a> 斐波那契数列。</p><h2 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a>剑指 Offer 11. 旋转数组的最小数字</h2><p>二分法，确定min_index在[left, mid]，还是在[mid, right]之间。注意下极端条件，比如：翻转0个的情况；所有数都相等的情况；最后剩余两个数的情况；mid和边界相等的情况等等</p><h2 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a>剑指 Offer 12. 矩阵中的路径</h2><p>DFS</p><h2 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a>剑指 Offer 13. 机器人的运动范围</h2><p>BFS，当然DFS也可以，不过BFS最合适，相当于一圈一圈地扩展范围</p><h2 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a>剑指 Offer 14- I. 剪绳子</h2><p>简单的动态规划，顺带提一下动态规划的三个关键点：</p><ol><li>划分子问题：一个大问题可以拆分为多个小问题，并且在大问题是最优解时，</li><li>状态转移公式</li><li>边界条件   </li></ol><p>是不是很像递归，因为动态规划一个最简单的实现方式就是递归。对于该题，三个关键点分别是：</p><ol><li>划分子问题：长度为n的绳子，最大乘积，等于将其分一部分、两部分、多部分的最大值。</li><li>状态转移公式：F(n) = max( (n-i) * F[i] for i in range(1, n))</li><li>边界条件：F(0) = 1; F(1) = 1   </li></ol><p>另外，由于该题要求至少分两段，因此需要对长度为最长时，稍微做一点特殊处理。</p><p>如果是递归实现，是会提示超时的，因为其中存在很多重复的计算。可以用递归的另外两种实现方式：备忘录法，自底向上法。</p><p>还有一种解法是根据数学规律，将n分为尽量多个3。这种解法不具通用性，就不介绍了。</p><h2 id="剑指-Offer-14-II-剪绳子-II"><a href="#剑指-Offer-14-II-剪绳子-II" class="headerlink" title="剑指 Offer 14- II. 剪绳子 II"></a>剑指 Offer 14- II. 剪绳子 II</h2><p>在 <a href="#剑指-offer-14--i-剪绳子">剑指 Offer 14- I. 剪绳子</a> 基础上，多了大数，就直接使用long类型，然后取模吧。</p><h2 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15. 二进制中1的个数"></a>剑指 Offer 15. 二进制中1的个数</h2><p>经典位运算题。n的每一位与 1 做 与操作，直到n变为0。</p><h2 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16. 数值的整数次方"></a>剑指 Offer 16. 数值的整数次方</h2><p>关键点，利用二分思想：   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pow(x, n) = pow(x, n//<span class="number">2</span>) ** <span class="number">2</span>  <span class="comment"># n为偶数   </span></span><br><span class="line">pow(x, n) = pow(x, n//<span class="number">2</span>) ** <span class="number">2</span> * x  <span class="comment"># n为奇数</span></span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-17-打印从1到最大的n位数"><a href="#剑指-Offer-17-打印从1到最大的n位数" class="headerlink" title="剑指 Offer 17. 打印从1到最大的n位数"></a>剑指 Offer 17. 打印从1到最大的n位数</h2><p>最大的n位数，是 pow(10, n)-1，遍历即可。<br>小心大数越界，如果是面试。</p><h2 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a>剑指 Offer 18. 删除链表的节点</h2><p>不再赘述。<br>值得一提：链表类问题，可以增加一个头结点dummy_head，这样可以使边界情况，处理起来方便很多。</p><h2 id="剑指-Offer-19-正则表达式匹配"><a href="#剑指-Offer-19-正则表达式匹配" class="headerlink" title="剑指 Offer 19. 正则表达式匹配"></a>剑指 Offer 19. 正则表达式匹配</h2><p>动态规划：（主串S, 模式串T）   </p><ol><li><p>划分子问题：如果S和T匹配，那么S和T的子串也匹配</p></li><li><p>状态转移公式：<br>为了避免每次都要检查，后一个字符串是否是”*”，从后往前遍历。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. T[i] 是普通字符</span><br><span class="line">    F(S, T) &#x3D; S[i] &#x3D;&#x3D; T[i] &amp;&amp; F(S[:-1], T[:-1])</span><br><span class="line"></span><br><span class="line">2. T[i] &#x3D;&#x3D; &#39;.&#39;，可以匹配任何字符</span><br><span class="line">    F(S, T) &#x3D; F(S[:-1], T[:-1])</span><br><span class="line"></span><br><span class="line">3. T[i] &#x3D;&#x3D; &#39;*&#39;，*前面的字符可以重复0次或多次</span><br><span class="line">    </span><br><span class="line">    3.1 S&#x3D;&#x3D;&quot;&quot;, 说明*前面的字符重复0次</span><br><span class="line">        F(S, T) &#x3D; F(S, T[:-2])</span><br><span class="line"></span><br><span class="line">    3.2 T[-2] &#x3D;&#x3D; &#39;.&#39; 或 S[-1] &#x3D;&#x3D; T[-2]，前一个字符能匹配上，则需考虑匹配0次、和多次的情况</span><br><span class="line">        F[S, T] &#x3D; F(S, T[:-2]) || F(S[:-1], T)   </span><br><span class="line"></span><br><span class="line">    3.3 S[-1] !&#x3D; T[-2]，前一个字符不匹配，相当于匹配了0次</span><br><span class="line">        F(S, T) &#x3D; F(S, T[:-2])</span><br></pre></td></tr></table></figure></li><li><p>边界条件:<br>边界条件，就是S、T一直递归匹配，直到某一个变为了空字符串</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. S &#x3D;&#x3D; &quot;&quot; &amp;&amp; T &#x3D;&#x3D; &quot;&quot;，return True</span><br><span class="line"></span><br><span class="line">2. S &#x3D;&#x3D; &quot;&quot; &amp;&amp; T !&#x3D; &quot;&quot;, 需要继续匹配，比如 S&#x3D;”“， T&#x3D;&quot;a*&quot;，是匹配的</span><br><span class="line"></span><br><span class="line">3. S !&#x3D; &quot;&quot; &amp;&amp; T &#x3D;&#x3D; &quot;&quot;, return False</span><br></pre></td></tr></table></figure></li></ol><h2 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a>剑指 Offer 20. 表示数值的字符串</h2><p>非常典型的一道<code>有限状态机</code>题，重点在于划分不同的状态，怕错不怕重复。状态之间的转移相对容易。</p><h2 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</h2><p>两个指针，pre指针从头开始遍历，post指针指向尾。每次pre指向一个偶数，就将其与post交换，直到两指针相遇。</p><h2 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a>剑指 Offer 22. 链表中倒数第k个节点</h2><p>快慢指针，不做赘述。</p><h2 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a>剑指 Offer 24. 反转链表</h2><p>三个指针，循环遍历即可。注意边界条件。</p><h2 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a>剑指 Offer 25. 合并两个排序的链表</h2><p>添加一个dummy头结点，然后对两个链表，执行类似一个归并排序的操作。</p><p><img src="/images/jian_zhi_offer.jpg" alt="CSRF示意图"></p>]]></content>
    
    <summary type="html">
    
      剑指offer 1-23 题，思路简结
    
    </summary>
    
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>人生的一些大道理</title>
    <link href="http://yoursite.com/2020/06/11/%E4%BA%BA%E7%94%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A4%A7%E9%81%93%E7%90%86/"/>
    <id>http://yoursite.com/2020/06/11/%E4%BA%BA%E7%94%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A4%A7%E9%81%93%E7%90%86/</id>
    <published>2020-06-11T08:25:13.000Z</published>
    <updated>2020-06-11T08:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<!-- 虽然明明没啥资格去说人生这种大事，毕竟我也是第一次经历，并且只经历了一种人生。   然鹅，还是想闲扯几句。也是看李笑来老师的书，说一下自己的想法。### 问题1. 工作，还是睡懒觉？首先，**单独就辛苦本身，不值得。** 如果你家财万贯，衣食无忧，房车不缺，干嘛非得让自己辛苦？即使你没有大富大贵，但对目前的生活还挺满意，也不想着去追求更加丰富、昂贵的东西啦，更加崇高的地位啦，那也没必要辛辛苦苦。这两种情况，自己对什么有兴趣，就去做什么，这就挺好的呗~简直是我的理想生活啊！然鹅，无论出于什么原因，**如果你想追求更好的，那辛苦就是值得的。**### 问题2. 生活是否公平？上帝是不公平的，付出了不一定有回报。   上帝是公平的，不付出，就一定没有回报。   哪怕买彩票，也得多买几次，才更容易中奖不是？人很少会后悔做了哪些事，但是常常后悔没做哪些事儿。   另外，高考真的是人生最公平、公正的一次。而且大学这个烙印将陪伴你终身。高中要好好学习啊，弟弟妹妹们。大学就无所谓，想做其他事就去做，别挂科就行。### 问题3. 你的，还是我的？街上碰到一个苹果，两个人同时看到了，这个苹果该属于谁呢？有人离得近，有人离得远，有人走过去，有人跑过去。不管怎样，先到达的那个有苹果吃。   同样，有人生来就离苹果近，有人生来跑得快，有人毅力强能坚持。谁会是最后的赢家？   我们不知道这个距离有多远，但是人生近百年，不是一场百米赛跑，而是一个马拉松。   苹果，强者得之。   所以，是我的。[doge]    --><p><img src="/images/kobe.jpeg" alt="">   </p><p><strong>Respect ！</strong></p>]]></content>
    
    <summary type="html">
    
      李笑来传话筒。
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>从CAS到无锁队列.md</title>
    <link href="http://yoursite.com/2020/06/03/%E4%BB%8ECAS%E5%88%B0%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/06/03/%E4%BB%8ECAS%E5%88%B0%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/</id>
    <published>2020-06-03T09:24:15.000Z</published>
    <updated>2020-06-03T09:24:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无锁算法"><a href="#无锁算法" class="headerlink" title="无锁算法"></a>无锁算法</h2><p>多个线程读写同一内存，如何做到不加锁呢？其实没有那么高大上的算法在里面，实现无锁的前提是，硬件需支持”读取-更新-写入“的原子操作，比如 Test and Set, Fetch and Add, Compare and Swap等。<br>以Compare and Swap，也就是CAS为例，可以实现很多无锁的数据结构，无锁队列，无锁树，区别在于需要几次的CAS。</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p><code>bool CAS(type* addr, type val_old, type val_new)</code><br>如果 addr 的值等于 val_old，就把它设置为 val_new，设置成功返回true，失败返回false。<strong>这个比较并赋值的操作，是一个原子操作。</strong></p><h2 id="无锁队列"><a href="#无锁队列" class="headerlink" title="无锁队列"></a>无锁队列</h2><p>我们使用一个单向链表，作为无锁队列的基础数据结构。利用CAS的原子性，来保证在push/pop，也就是在链表尾/头添加、删除节点时，不会出现多线程互相覆盖的问题。</p><p>直接看代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很久没写C/CPP，语法细节忘了不少，忽略忽略</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    node* tail  <span class="comment">// 尾指针</span></span><br><span class="line">    node* head  <span class="comment">// 头指针</span></span><br><span class="line">&#125;* Q</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Q是队列，data是待push的节点</span></span><br><span class="line">Push(Q, data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> </span><br><span class="line">    &#123;</span><br><span class="line">        p = Q-&gt;tail;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">CAS</span><span class="params">(p-&gt;next, <span class="literal">NULL</span>, data)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果此时p还是Q的tail，才能设置成功</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新Q的tail，如果此时tail还是p，才能设置成功。</span></span><br><span class="line">    <span class="comment">// 此时不用担心失败，因为如果此处不更新tail，其他线程拿到的总是旧的tail，</span></span><br><span class="line">    <span class="comment">// 其他线程在while循环中的CAS，会发现p-&gt;next!=NULL，就会失败, 一直处于while循环中</span></span><br><span class="line">    CAS(Q-&gt;tail, p, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Pop(Q)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> </span><br><span class="line">    &#123;</span><br><span class="line">        p = Q-&gt;head</span><br><span class="line">        <span class="keyword">if</span> CAS(Q-&gt;head, p, p-&gt;next) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于CAS会直接用新值覆盖旧值，为了保存旧值，所以每次都会先把旧值取出来。然后在设新值时，要判断旧值是否发生了变化。<br>那么以上实现有什么问题没？</p><ol><li><p>问题1，死循环<br>考虑一些意外的情况。对于Push，如果线程第一个CAS执行成功，在执行第二个CAS时宕掉。此时 tail 未更新，其他线程会发现tail.next总是不为空，因此就会陷入while死循环。</p></li><li><p>问题2，<strong>ABA问题</strong><br>比如，一个线程按序执行了 pop -&gt; push操作，而push的节点，恰巧复用了被pop节点同一块内存。因为此链表例子中，CAS比较的是内存地址，所以校验通过。而里面的值其实是发生了变化的，如果不校验里面的值，可能会认为节点未被改动。</p></li></ol><p>这两个问题如何解决呢？   </p><ol><li>死循环问题</li></ol><ul><li>关键：tail节点未更新，导致CAS(p-&gt;next, NULL, data) 总是失败，因此可以让每个线程发现这个问题后，自己去更新tail节点。</li></ul><ol start="2"><li>ABA问题   </li></ol><ul><li>节点增加计数器，每一次更新。计数的增减操作也需要原子化。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无锁数据结构的大致思想就是这样。<br>借助CAS，一个极端的想法，所有程序都可以做成无锁的。只需要对任何一个变量的读写，都使用CAS操作，失败则从头开始。此时，虽然实现了无锁，但是效率却是降低的，因此，无锁也有它的适用场景 — <strong>读多写少</strong>。因此此时CAS的冲突率比较小。<br>与CAS比较像的一个机制，是自旋锁。自旋锁总是在尝试<strong>加锁</strong>，而CAS总是在尝试<strong>比较-修改</strong>，都算是<strong>忙等</strong>机制。</p>]]></content>
    
    <summary type="html">
    
      从无锁思想到CAS，再到具体实现，以无锁队列为例。
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法思想" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>PathEscape与QueryEscape</title>
    <link href="http://yoursite.com/2020/05/29/PathEscape%E4%B8%8EQueryEscape/"/>
    <id>http://yoursite.com/2020/05/29/PathEscape%E4%B8%8EQueryEscape/</id>
    <published>2020-05-29T04:56:52.000Z</published>
    <updated>2020-05-29T04:56:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>在给client种cookie时，发现个问题，种进去的加密cookie，解密时总报错。<br>原因是：golang中，对一个字符串做url转义有两个方法，<code>url.PathEscape()</code>和<code>url.QueryEscape</code>。但是两个方法的行为有些区别。两者混用导致，编码和解码后，和原始字符串不一致。</p><h3 id="1-举个例子，直接对比下效果"><a href="#1-举个例子，直接对比下效果" class="headerlink" title="1. 举个例子，直接对比下效果"></a>1. 举个例子，直接对比下效果</h3><p>以 + 和 空格 这两个字符为例。   </p><table><thead><tr><th align="center">待转义字符</th><th align="center">PathEscape</th><th align="center">QueryEscape</th><th align="center">PathUnEscape</th><th align="center">QueryUnEscape</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">+</td><td align="center">%2B</td><td align="center">+</td><td align="center">空格</td></tr><tr><td align="center">空格</td><td align="center">%20</td><td align="center">+</td><td align="center">空格</td><td align="center">空格</td></tr></tbody></table><h3 id="2-具体功能"><a href="#2-具体功能" class="headerlink" title="2. 具体功能"></a>2. 具体功能</h3><h4 id="2-1-PathEscape"><a href="#2-1-PathEscape" class="headerlink" title="2.1 PathEscape"></a>2.1 PathEscape</h4><p>对特殊字符串进行转义，以便其可以作为url路径的一部分。就是URL地址两个 / 之间的部分</p><h4 id="2-2-QueryEscape"><a href="#2-2-QueryEscape" class="headerlink" title="2.2 QueryEscape"></a>2.2 QueryEscape</h4><p>对特殊字符串进行转义，以便其可以作为url query的参数，也就是 ？后面那一串kv。</p><h4 id="2-3-对比"><a href="#2-3-对比" class="headerlink" title="2.3 对比"></a>2.3 对比</h4><ol><li><p>两者的共同点在于：都会将一些特殊字符，转义为<code>%AB</code>的形式。特殊字符的定义为，除<code>a-z，A-Z，0-9，- _ ~ · , / ; ?</code> 的字符。</p></li><li><p>不同点在于：对于一些特殊字符，转义行为不同。</p></li></ol><table><thead><tr><th align="center">字符</th><th align="center">PathEscpae</th><th align="center">QueryEscape</th></tr></thead><tbody><tr><td align="center">$</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">&amp;</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">+</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">:</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">=</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">@</td><td align="center">Y</td><td align="center">N</td></tr></tbody></table><p>具体的可参考RFC文档（URI、URL的两篇）和Golang的源码。（Golang源码更简单直接）</p><h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h3><p>其他语言似乎没分得那么清，具体实现上也有一些区别，比如python/javascript，encode行为就和golang的不一致。总之，同一语言，如golang，QueryEscape编码后，一定要配合QueryUnEscape使用。</p><p>一些细节也不同，比如JS里的encodeURI和encodeURIComponent。可以理解为，encodeURI，是把参数当做一个完整的URI在编码，而encodeURIComponent是把参数当做URI的一个segment。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS里</span></span><br><span class="line"><span class="built_in">encodeURI</span>(<span class="string">"12+34 56"</span>)</span><br><span class="line">output: <span class="string">"12+34%2056"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">encodeURIComponent</span>(<span class="string">"12+34 56"</span>)</span><br><span class="line">output: <span class="string">"12%2B34%2056"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"http://www.ruanyifeng.com/blog/2010/02/url_encoding.html"</span></span><br><span class="line"><span class="built_in">encodeURI</span>(a)</span><br><span class="line">output: <span class="string">"http://www.ruanyifeng.com/blog/2010/02/url_encoding.html"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">encodeURIComponent</span>(a)</span><br><span class="line">output: <span class="string">"http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2010%2F02%2Furl_encoding.html"</span></span><br></pre></td></tr></table></figure><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ol><li><a href="http://www.ruanyifeng.com/blog/2010/02/url_encoding.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2010/02/url_encoding.html</a></li><li><a href="https://tools.ietf.org/html/rfc1738" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc1738</a></li><li><a href="https://tools.ietf.org/html/rfc3986" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc3986</a></li></ol>]]></content>
    
    <summary type="html">
    
      搞懂PathEscape与QeuryEscape区别
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>关于工作的一些想法.md</title>
    <link href="http://yoursite.com/2020/05/28/%E5%85%B3%E4%BA%8E%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/"/>
    <id>http://yoursite.com/2020/05/28/%E5%85%B3%E4%BA%8E%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/</id>
    <published>2020-05-28T06:36:40.000Z</published>
    <updated>2020-05-28T06:36:40.000Z</updated>
    
    <content type="html"><![CDATA[<!-- 0. 工作的目的1. 浮于表面，不用思考2. 重复性，还是不用思考 --><p>待写。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- 0. 工作的目的

1. 浮于表面，不用思考

2. 重复性，还是不用思考 --&gt;

&lt;p&gt;待写。。&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>常见web安全总结</title>
    <link href="http://yoursite.com/2020/05/25/%E5%B8%B8%E8%A7%81web%E5%AE%89%E5%85%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/05/25/%E5%B8%B8%E8%A7%81web%E5%AE%89%E5%85%A8%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-25T08:20:55.000Z</published>
    <updated>2020-05-25T08:20:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="XSS，跨站脚本攻击"><a href="#XSS，跨站脚本攻击" class="headerlink" title="XSS，跨站脚本攻击"></a>XSS，跨站脚本攻击</h3><p>XSS的根本原因是，前端页面被嵌入一些恶意代码，这些恶意代码可能通过不同途径，注入进来。根据不同注入途径（或着说方式），可以分为反射型、持久型。</p><ol><li>反射型XSS   </li></ol><ul><li>恶意伪造url -&gt; 骗取用户点击 -&gt; 页面从url取参数进行渲染。从而参数里的恶意代码被执行。</li><li>案例：微博hellosamy事件</li></ul><ol start="2"><li>持久性XSS   </li></ol><ul><li>在留言板、评论等场景提交恶意代码 -&gt; 后台未经处理，直接保存了前端提交的数据，-&gt; 再次访问或其他人访问时，前端展示相关内容，又把这些数据取出来进行渲染，从而恶意代码被执行。  </li><li>案例：微信公众号XSS事件</li></ul><ol start="3"><li><p>应对：</p><ol><li>用户提交的数据，入库前预处理，很多xssfilter</li><li>前端拼接Html时，也要做充分转义</li><li>为了防止cookie盗用，重要cookie设置http-only为true</li></ol></li><li><p>参考   </p><blockquote><p><code>https://tech.meituan.com/2018/09/27/fe-security.html</code></p></blockquote></li></ol><h3 id="CSRF，跨站请求伪造（英語：Cross-site-request-forgery）"><a href="#CSRF，跨站请求伪造（英語：Cross-site-request-forgery）" class="headerlink" title="CSRF，跨站请求伪造（英語：Cross-site request forgery）"></a>CSRF，跨站请求伪造（英語：Cross-site request forgery）</h3><p>本质是浏览器在发起请求时，会自动带上对应域名下的cookie。该特性可能导致，用户在访问恶意网站时，在用户不知不觉的情况下，触发一些携带了用户身份信息（cookie）的请求。如下图所示：<br><img src="/images/csrf.jpg" alt="CSRF示意图"></p><blockquote><ol><li>银行网站A，它以GET请求来完成银行转账的操作，如：<a href="http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000" target="_blank" rel="noopener">http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000</a></li><li>危险网站B，它里面有一段HTML的代码如下：<pre><code class="html">　　<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">http://www.mybank.com/Transfer.php?toBankId</span>=<span class="string">11&amp;money</span>=<span class="string">1000</span>&gt;</span></code></pre></li><li>首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块……</li></ol></blockquote><p>在访问危险网站B的之前，你已经登录了银行网站A，而B中的img以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取src指向的资源，结果银行网站服务器收到请求后，判断身份通过，所以就立刻进行转账操作……</p><p>该例子里，一方面是由于用户上了小网站，另一方面，不应该用GET请求去更新资源（更改账户）。因为像src/script等标签都是默认用GET获取资源，如果再对前端熟悉一些的，可能会想到jsonp，就是利用script标签实现的。<br>很多邮箱图片默认不展示，CSRF也是原因之一。当然还有很多其他的风险，这个可以单开一篇，开开脑洞。</p><ol><li><p>vs 跨域？<br>很多人会有疑问，浏览器不是有跨域限制吗，为什么还会出现在A页面，访问B服务器的情况。对于跨域请求，<strong>浏览器还是会正常发出</strong>，收到response后，会判断源和当前页面的源是否是属于同源，如果不属于，则需要根据<code>access-control-allow-origin</code>等header，判断server端是否允许跨域。   </p></li><li><p>应对<br>主要通过两个关键点：   </p><ol><li>虽然A网站可以向B服务器发请求，但是由于跨域限制，没法处理对应的response。因此一些更新资源的操作，最好用POST，更好的是使用restful风格。另一方面，也可以增加二次确认，比如引入验证码，实际上相当于一个动态的token。</li><li>由于正规的浏览器，对cookie访问，也要求同源。因此可以再query里增加一些cookie里才有的信息，在服务端校验query和cookie里对应的参数，如果不一致则为恶意。   </li></ol></li></ol><p>其他的方法，还有增加referer，但是有的时候请求不带referer，比如非http协议页面发出的请求（ftp之类的）、https页面发出的http请求等，因此该方法有一定的漏洞。</p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>关键点：<br>    1. 不要相信请求携带的参数，不要直接拿过来拼接SQL语句。<br>SQL注入的防范很成熟，使用prepare statement即可，常用的client lib里都会实现。但是表名不支持参数化，因此表名还是得使用代码拼接的方式。这就要求表名不能是前端输入的，或者增加表名白名单校验。   </p><blockquote><p>从一条sql执行过程来说，编译 -&gt; 执行。一般情况是连带参数，一起编译，就会出现注入情况。<br>  使用参数化查询的形式，会提前对模板进行预编译，而每个?占位的参数，只会被数据库当做一个完整的参数处理。</p></blockquote>]]></content>
    
    <summary type="html">
    
      总结常见的几种Web安全问题，包括XSS、CSRF、SQL注入。
    
    </summary>
    
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="安全" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>MySQL知识点</title>
    <link href="http://yoursite.com/2020/05/20/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2020/05/20/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2020-05-20T03:09:35.000Z</published>
    <updated>2020-05-20T03:09:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="范式与反范式"><a href="#范式与反范式" class="headerlink" title="范式与反范式"></a>范式与反范式</h2><table><thead><tr><th>范式</th><th>描述</th><th>反例</th></tr></thead><tbody><tr><td>第一范式</td><td>每个字段都是原子的，不能再分解</td><td>某个字段是json串</td></tr><tr><td>第二范式</td><td>1. 表必须有主键；2. 非主属性，必须完全依赖主键，而不能只依赖主键的一部分字段。</td><td>好友关系表，关注人ID+被关注人ID作为主键，还存储了关注人的头像，这个只依赖于主键的一个字段。</td></tr><tr><td>第三范式</td><td>非主属性，直接依赖主键，而非间接依赖。</td><td>员工表，有部门ID和部门名称等，部门名称依赖部门ID，而不是员工ID，不应在员工表中。</td></tr></tbody></table><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>比如电商订单表，有三个查询纬度：订单ID，用户ID，商户ID。</p><ol><li>建立主纬度和辅助纬度之间的一个映射表<br>比如，以订单ID拆分，那么要保存用户ID-&gt;订单ID和商户ID-&gt;订单ID的映射表。然而问题是：<ol><li>映射表本身也要分表</li><li>每个订单，要写入多个库，属于分布式事务问题。通常会由后台任务，定时对比，保证多库表最终一致。</li></ol></li><li>业务双写<br>存多份数据，但是拆分纬度不一样。一套按用户ID划分，一套按商户号划分。同样存在写入多个库的分布式事务问题。</li><li>异步双写<br>还是多份数据，业务单写一份，然后通过监听binlog，同步到其他表上</li><li>多个纬度统一到一个纬度<br>比如把订单ID和用户ID统一成一个维度，然后把用户ID作为订单ID的一部分。这样，订单ID中就包含了用户ID的信息，然后按照用户ID分库，当按订单ID查询的时候，提取出用户ID，再按用户ID查询。   </li></ol><p><strong>总之就是，拆分依据的维度，要同时在多个原始ID中提现</strong></p><h2 id="分库分表后的Join问题"><a href="#分库分表后的Join问题" class="headerlink" title="分库分表后的Join问题"></a>分库分表后的Join问题</h2><ol><li>join拆分为多个单表查询，在应用层代码里做join处理</li><li>增加宽表，提前join好</li><li>利用搜索引擎，比如ES，将DB数据导入ES中</li></ol><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><ol><li>最好是优化业务，避免跨库事务</li><li>如果无法避免，参考笔记：分布式事务一致性</li></ol><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><p>相比hash索引，以及类似结构的KV缓存或数据库，有以下特性</p><ol><li>范围查询</li><li>前缀匹配，模糊查询</li><li>排序和分页</li></ol><h3 id="2-物理结构"><a href="#2-物理结构" class="headerlink" title="2. 物理结构"></a>2. 物理结构</h3><ol><li>磁盘属于块设备，innoDB读写磁盘，是以page为基本单位，page默认大小是16KB，每次I/O都是16KB的整数倍。   </li><li>innoDB为每个Page赋予一个32位的全局编号，因此innoDB的存储上限是<strong>64T</strong> (2^32 * 16KB)。<br>如果用来装非叶子节点，假如key是64位整数，也就是8字节，加上其他字段，按16字节算，一个page可以装1000个key。基于此估算，一个三层的B+树，可以存储的数据量：<ol><li>第一层：根节点，一个page，1000个key。16KB内存，对应1000个子节点</li><li>第二层：1000个节点，每个节点一个page，每个page又可以有1000个子节点。16MB内存，对应1000 * 1000个子节点</li><li>第三层：1000 * 1000个节点，每个节点一个page。那么该表的最大容量是：1000 * 1000 * 16KB = 16GB。<strong>只需要16MB的内存索引，只需要一次I/O读取叶子节点</strong>    </li></ol></li><li>叶子page内部，以单向链表的方式，存储一条条的记录</li><li>非主键索引，索引树叶子节点存的是主键的value。</li></ol><h2 id="事务与锁"><a href="#事务与锁" class="headerlink" title="事务与锁"></a>事务与锁</h2><h3 id="1-隔离级别"><a href="#1-隔离级别" class="headerlink" title="1. 隔离级别"></a>1. 隔离级别</h3><table><thead><tr><th>隔离级别</th><th>解决问题</th></tr></thead><tbody><tr><td>Read Uncommited</td><td></td></tr><tr><td>Read commited</td><td>解决脏读</td></tr><tr><td>Repeatable Read</td><td>解决幻读（通过间隙锁），innoDB默认级别。MVCC需要结合行锁，实现当前读，解决update时的覆盖问题。</td></tr><tr><td>Serialization</td><td></td></tr></tbody></table><h3 id="2-死锁检测"><a href="#2-死锁检测" class="headerlink" title="2. 死锁检测"></a>2. 死锁检测</h3><ol><li>判断一个有向图是否存在环，dfs、拓扑排序</li><li>死锁的发生，与代码有关，也与事务隔离级别有关，因为隔离级别会影响加锁机制。</li><li>复杂度是O(N)</li></ol><h3 id="3-innoDB的MVCC实现"><a href="#3-innoDB的MVCC实现" class="headerlink" title="3. innoDB的MVCC实现"></a>3. innoDB的MVCC实现</h3><ol><li>每一行都有两个隐藏列，<strong>最近修改的事务ID</strong> + <strong>undolog里回滚段指针（便于回滚）</strong></li><li>一致性视图，{low_trx_id, up_trx_id, trx_ids}   <ul><li>low_trx_id: 当前事务链表，最小的事务id</li><li>up_trx_id:  当前事务链表，最大的事务id</li><li>trx_ids: 正在执行的事务的id集合<br>通过比较当前事务id，与以上三个变量的关系，确定某个版本数据，是否对当前事务可见。</li></ul></li></ol><h3 id="4-事务实现"><a href="#4-事务实现" class="headerlink" title="4. 事务实现"></a>4. 事务实现</h3><h4 id="1-WAL-Write-Ahead-Log"><a href="#1-WAL-Write-Ahead-Log" class="headerlink" title="1. WAL, Write-Ahead Log"></a>1. WAL, Write-Ahead Log</h4><p>内存操作数据 + write-ahead log</p><h4 id="2-Redo-Log的逻辑与物理结构"><a href="#2-Redo-Log的逻辑与物理结构" class="headerlink" title="2. Redo Log的逻辑与物理结构"></a>2. Redo Log的逻辑与物理结构</h4><ol><li>redo log 物理组成结构<ol><li>一个逻辑事务 包含 多个物理事务mtr，Mini Transaction</li><li>每个mtr对应一个LSN</li><li>一个LSN对应若干个连续的block</li><li>这些block，最终组成了 redo log   <blockquote><p>综上，一个事务在redo log里，可能有多个LSN，这些LSN自己是连续的，但是多个LSN不一定是连续的。</p></blockquote></li></ol></li><li>redo log 日志内容格式<ol><li>先以page为单位记录日志</li><li>在每个page里面再采用物理记法<blockquote><p>比如 (page id, record offset, (field1, value1)..(fieldi, valuei)…)   </p></blockquote></li></ol></li><li>Aries恢复算法<ol><li>分析阶段<br>从上一个checkpoint开始，开始分析哪些事务执行完了，未刷写page；哪些事务执行了一半，需要回滚。checkpoint机制，可以加快分析速度</li><li>redo阶段<br>对已经commit的事务，执行redolog，刷写page。redolog是幂等的，重复执行没关系。</li><li>undo阶段<br>对于未commit的事务，执行undolog，回滚</li></ol></li><li>其他<ol><li>每个page上记录了，上次修改的LSN，因此恢复时，如果redolog里的lsn&lt;page lsn，说明不用重写了。</li><li>redolog保证的是事务的持久性，写入成功，则不会丢失</li></ol></li></ol><h4 id="3-Undo-log"><a href="#3-Undo-log" class="headerlink" title="3. Undo log"></a>3. Undo log</h4><ol><li>redolog按LSN的顺序，而undolog没有顺序，多个事务并行写。每条日志除下记录主键ID和数据外，还有两个字段：修改记录的事务ID和回滚指针，用来串联所有历史版本，就是MVCC的两个隐藏列。</li><li>undo log 只在commit的过程中有用，一旦事务commit了，就可以删掉undo log</li><li>通俗一点，修改行前，先把行拷贝一份出来，这些历史版本形成一个链表。</li></ol><h2 id="各种锁"><a href="#各种锁" class="headerlink" title="各种锁"></a>各种锁</h2><ol><li>有不同的划分标准，比如按粒度，有表锁、行锁、gap锁；按锁的模式，有共享锁、排他锁、意向锁等</li><li>MySQL加锁问题与隔离级别有关，如果隔离级别是Read Commited，则不需要gap锁，因为RC允许幻读。</li><li>具体到各种锁<ol><li><code>全局锁</code>：对整个DB加锁，一些不支持事务的引擎，可以在备份前，锁住DB</li><li><code>MDL</code>，元数据锁：MDL分读/写，不需显式调用。MDL也是在语句执行时隐式加，在事务提交后释放。比如在对表做CURD时，加MDL读锁；对表做DDL时，加MDL写锁。</li><li><code>表锁</code>，读/写，共享/排他，S/X</li><li><code>行锁</code>，读/写，共享/排他，S/X</li><li><code>意向锁</code>，意向锁也是表级别，但是意向锁之间互不排斥，包括IX（意向写）与IX也不互斥。意向锁的目的是提高在加表锁时的判断效率。如果事务要给表中某一行加X锁，首先要对表加IX锁；如果要给某一行加S锁，就先对表加IS锁。这也是“意向”一词的含义。<br>如果一个事务要对表加X锁，就可以根据表有没有被其他事务加IS/IX锁，就可得知，有没有其他事务在读写该表。</li><li><code>间隙锁</code>，解决幻读问题</li><li><code>AI锁</code>，表级别，针对自增ID生成器，如果事务rollback，自增ID一列会不连续</li></ol></li></ol><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ol><li><p>double write 机制   </p><p> InnoDB的page size一般是16KB，其数据校验也是针对这16KB来计算的，将数据写入到磁盘是以page为单位进行操作的。操作系统写文件是以4KB作为单位的，磁盘IO是以512字节为单位的，那么每写一个InnoDB的page到磁盘上，操作系统需要写4个块。而计算机硬件和操作系统，在极端情况下（比如断电）往往并不能保证这一操作的原子性，16K的数据，写入4K时，发生了系统断电或系统崩溃，只有一部分写是成功的，这种情况下就是partial page write（部分页写入）问题。这时page数据出现不一样的情形，从而形成一个”断裂”的page，使数据产生混乱。这个时候InnoDB对这种块错误是无 能为力的.   </p><p> 有人会认为系统恢复后，MySQL可以根据redo log进行恢复，而MySQL在恢复的过程中是检查page的checksum，checksum就是pgae的最后事务号，发生partial page write问题时，page已经损坏，找不到该page中的事务号，就无法恢复。   </p><p> 为了解决该问题，写数据page时，写两遍到磁盘，第一遍是写到double write buffer文件上, 第二遍是从double write buffer写到真正的数据文件中。如果宕机重启，发现page损坏，可以从double write buffer中恢复。   </p><p> 因为redo log的写入单位就是512字节，也就是磁盘IO的最小单位，因此可以保证原子性，不会导致数据损坏。</p></li></ol>]]></content>
    
    <summary type="html">
    
      总结一些mysql的知识点，包括范式、索引、事务、锁等等。
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>对CAP的正确理解</title>
    <link href="http://yoursite.com/2020/05/14/CAP/"/>
    <id>http://yoursite.com/2020/05/14/CAP/</id>
    <published>2020-05-14T03:06:27.000Z</published>
    <updated>2020-05-14T03:06:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><ol><li>C，一致性，多副本一致性，事务一致性等</li><li>A，可用性</li><li>P，分区容忍性</li></ol><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ol><li>最大的误解：<strong>CAP可以三选二</strong><br>实际上P是必然存在的，只能在C和A（一致性和可用性）之间权衡。实际中大多是AP或CP系统，很少有CA的系统。</li><li>AP系统，追求可用性，放弃一致性。比如MySQL主从等。</li><li>CP系统，追求强一致性，牺牲一定的可用性。raft、zab协议。而此时的一致性，也只是对客户端看来是一致的，对内部看，是最终一致，因为同步数据总需要时间。</li><li>对于CA系统，因为要实现A（高可用），就必然有冗余，有冗余就必然存在P。比如MySQL，内部事务实现强一致性C，但是单机无法保证A，单机也不存在网络延迟，因此可以满足P。</li><li>只要引入冗余，实现的高可用（A），就一定存在P。如果还想兼顾一致性（C），那么一定不是真的A。<strong>因此实际系统中，总是在CA之间做权衡。放弃某一方，就变成了AP或CP。</strong></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;CAP&quot;&gt;&lt;a href=&quot;#CAP&quot; class=&quot;headerlink&quot; title=&quot;CAP&quot;&gt;&lt;/a&gt;CAP&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;C，一致性，多副本一致性，事务一致性等&lt;/li&gt;
&lt;li&gt;A，可用性&lt;/li&gt;
&lt;li&gt;P，分区容忍性&lt;/li&gt;
&lt;/o
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Map并发安全实现原理</title>
    <link href="http://yoursite.com/2020/05/14/map%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/05/14/map%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2020-05-14T03:03:32.000Z</published>
    <updated>2020-05-14T03:03:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java-Concurrent-hashmap"><a href="#Java-Concurrent-hashmap" class="headerlink" title="Java Concurrent hashmap"></a>Java Concurrent hashmap</h3><ol><li>多个segment，支持最大segment数量的并发访问<blockquote><p>ps: 如果hash桶的list过长，可以使用红黑树代替list</p></blockquote></li></ol><h3 id="golang-sync-Map"><a href="#golang-sync-Map" class="headerlink" title="golang sync.Map"></a>golang sync.Map</h3><ol><li>read-only, dirty 两个字段将读写分离</li><li>read-only不需加锁，读或写dirty都需要加锁</li><li>misses字段，统计read-only穿透次数，超过一定次数将dirty同步到read-only上</li><li>删除时，通过给read-only添加标记，延迟删除</li><li>读的时候，先查询read，不存在时查询dirty；写入时则只写入dirty</li><li>写入过程，每次写入时，先copy 未删除的read-only到dirty中，然后将k-v存入dirty。<blockquote><p>read-only可以当做dirty的缓存。dirty里的数据，总比read-only的多。</p></blockquote></li><li><strong>适用于读多写少的场景。写入较多时，性能无法保证。</strong></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java-Concurrent-hashmap&quot;&gt;&lt;a href=&quot;#Java-Concurrent-hashmap&quot; class=&quot;headerlink&quot; title=&quot;Java Concurrent hashmap&quot;&gt;&lt;/a&gt;Java Concurrent h
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>各种树结构</title>
    <link href="http://yoursite.com/2020/05/13/%E5%90%84%E7%A7%8D%E6%A0%91%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/05/13/%E5%90%84%E7%A7%8D%E6%A0%91%E7%BB%93%E6%9E%84/</id>
    <published>2020-05-13T02:21:07.000Z</published>
    <updated>2020-05-13T02:21:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="B树-vs-B-树-vs-B-树"><a href="#B树-vs-B-树-vs-B-树" class="headerlink" title="B树 vs B+树 vs B*树"></a>B树 vs B+树 vs B*树</h3><ol><li><p>B树，B是指发明人的名字</p><ul><li>平衡多路搜索树</li><li>保持键值有序，以顺序遍历</li><li>使用不完全填充的节点块，来加速插入和删除</li><li>节点块至少半满，提升空间利用率</li></ul></li><li><p>B+树 VS B树</p><ul><li>非叶子节点，只保存索引：从而可以减少索引树的大小，内存里可以保存更多的索引。由于每次都需要走到叶子节点，查询时间也更稳定。</li><li>叶子节点之间，增加链指针，方便遍历</li></ul></li><li><p>B*树<br>在B+树的基础上</p><ul><li>非根和非叶子节点，增加指向兄弟的指针</li><li>插入时，如果节点已满，会检查兄弟节点是否满，未满，则向兄弟节点转移数据；已满，则从当前节点和兄弟节点，各拿出1/3数据，创建一个新节点。<br>从而节点空间利用率更高，节点分裂的情况也减少。</li></ul></li></ol><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><ol><li>也是一种BST(二叉搜索树)，但是不要求完全平衡</li><li>牺牲部分平衡性，达到较快的插入和删除性能</li><li>使用场景：linux CFS调度，nginx timer等</li><li>vs B树: B树作为多路搜索，能够在树深较小的情况下，支持更多的数据节点。对于磁盘类操作，可以避免大量的随机IO（一个磁盘page，可以读取到更多的索引，类似MySQL），从而优化读写性能。而红黑树一般整棵树都在内存里，不涉及到磁盘操作，支持的数据量较小，但是由于各种操作优于BST，因此常用于涉及到排序、搜索的场景。比如CFS，为了保证公平调度，每次选取当前执行总时间最小的线程执行。</li></ol><h3 id="LSM，Log-Structured-Merged-Tree"><a href="#LSM，Log-Structured-Merged-Tree" class="headerlink" title="LSM，Log-Structured Merged Tree"></a>LSM，Log-Structured Merged Tree</h3><ol><li><p>核心思想：<strong>放弃部分读性能，提高写性能。</strong> 适用于kv存储。</p></li><li><p>内存中的memtable，磁盘上的sstable。读取的时候，需要遍历sstable，这里的 优化是，使用是bloom filter，确定一个Key是否在sstable里。</p></li><li><p>一般LSM-Trees会配合内存排序，内存里将写数据缓冲（通常是一个红黑树、跳表之类的结构）。等积累得足够多之后，使用归并排序将数据合并，写入磁盘。</p></li><li><p>应用：rocksDB，levelDB，hbase</p><ul><li><p>rocksDB：c++编写的kv存储引擎，基于levelDB改造</p></li><li><p>levelDB：kv存储引擎</p></li><li><p>hbase: 分布式存储，列数据库，应对大量数据（亿级以上）   </p><p>这些思想类似lsm，但也有一些优化和改进，比如levelDB为了避免sstable过多，以及降低sstable合并过程中的开销，增加了level的概念。如果没有level，新sstable需要和旧的sstable比较，随着数据量的增多，新sstable需要和越来越多的sstable合并，从而效率降低。（如果每次合并后只留下一个大的sstable，效率一样会降低，因为涉及到插入操作。）有了level，上下层level，待比较的相关sstable数量将会得到控制。从而加快压缩、合并的过程。<br>除下按分层合并，还有按大小合并，hbase使用该种方法。两种思想，一种是更新的和更老的合并，一种是更小的和更大的合并。</p><p>sstable会保存所有写入的值（K-V），新的value并不会覆盖旧的value，而是读取的时候，从新的segment开始找，找到就停下。压缩、合并的过程，就是保留新的value，去除旧的value的过程。<br>另外，为了防止系统崩溃，数据丢失，也会使用额外的WAL日志。相当于每次写入，需要更新有序的memtable，以及append WAL日志。   </p><p>Lucene(ES的索引引擎)，也是用了类似的思想存储它的倒排索引。首先根据类lsm思想找到单词对应的倒排索引值（文档ID列表），再根据文档ID，获取具体的文档。</p></li></ul></li><li><p>参考资料</p><ul><li><a href="http://blog.fatedier.com/2016/06/15/learn-lsm-tree/" target="_blank" rel="noopener">http://blog.fatedier.com/2016/06/15/learn-lsm-tree/</a></li></ul></li></ol><h3 id="lsm-vs-b-树"><a href="#lsm-vs-b-树" class="headerlink" title="lsm vs b+树"></a>lsm vs b+树</h3><ol><li><p>查询过程<br>为了快速查询，一个办法是建立hash索引，但是hash索引占用空间太大，而且不支持区间查询。另一个办法是，事先对数据进行排序，B+树，把排序的操作放在了写入的时候，读的时候便轻松一些。   </p></li><li><p>写过程<br> 但是B树面对高并发写的时候，压力很大。B树把所有的压力都放到了写操作的时候，从根节点索引到数据存储的位置，可能需要多次读文件；真正插入的时候，又可能会引起page的分裂，多次写文件。   </p><p> LSM在写的时候，直接写入内存，然后利用红黑树保持内存中的数据有序，由后台线程定期或被触发，去merge和持久化到磁盘。也会使用WAL方式记录log，避免数据丢失。  </p><p> 当写比读多时，LSM树相比于B树有更好的性能。因为随着insert操作，为了维护B树结构，节点分裂。读磁盘的随机读写概率会变大，性能会逐渐减弱。LSM把多次IO，批量变成一次IO，复用了磁盘寻道时间，极大提升效率。</p></li><li><p>总结下，通常LSM树的写入更快，B树的读取速度更快。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;B树-vs-B-树-vs-B-树&quot;&gt;&lt;a href=&quot;#B树-vs-B-树-vs-B-树&quot; class=&quot;headerlink&quot; title=&quot;B树 vs B+树 vs B*树&quot;&gt;&lt;/a&gt;B树 vs B+树 vs B*树&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;B树，B是
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="http://yoursite.com/2020/05/12/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://yoursite.com/2020/05/12/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2020-05-12T13:35:11.000Z</published>
    <updated>2020-05-12T13:35:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><ol><li>set key val nx ex</li></ol><ul><li>优点：实现简单，性能好</li><li>缺点：超时时间不好控制，极端情况，会出现超时后，多个节点获取到同一把锁的情况。</li></ul><ol start="2"><li>问题<ol><li>主从，redis主从采用异步复制，那么如果主机宕机，切换到从，会导致部分锁数据丢失。此时，多个client会拿到同一把锁。</li><li>如果锁没有设置超时，若client挂掉，则锁永远不会释放</li><li>如果锁设置了超时，若client阻塞或业务执行超时，也会导致多个client拿到同一把锁。</li></ol></li></ol><h3 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h3><ol><li>使用临时顺序节点，如果自己是子节点的第一个，则表示加锁成功。否则，watch上一个，如果上一个释放，表示轮到自己了。</li></ol><ul><li>优点：一般情况，不存在client宕机/超时问题，zk感知到client宕机，会自动删除对应的临时顺序节点，相当于自动释放锁，或者取消自己的排队。</li><li>缺点：实现复杂，吞吐量不高</li></ul><ol start="2"><li>问题<ol><li>因为zk使用心跳判断client是否在线，如果网络超时或者full GC等等，导致zk认为client宕机，则会释放锁。导致其他client同时获得该锁。<strong>但是这种情况很少见，相比之下，client处理超时这种更常见，这也是zk比redis方案好的原因。</strong></li></ol></li></ol><h3 id="mysql行锁"><a href="#mysql行锁" class="headerlink" title="mysql行锁"></a>mysql行锁</h3><ul><li>优点：不需引入额外中间件</li><li>缺点：吞吐量不高；也存在client宕机超时问题</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>探测client是否宕机很难，如果因为超时，那就不应该释放锁。如果是因为宕机，那就应该释放锁。</li><li><code>没有完美的方案，实际场景中，分布式锁只应作为辅助手段，比如为了减少DB的压力等，不应仅靠它控制业务并发逻辑。</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;redis&quot;&gt;&lt;a href=&quot;#redis&quot; class=&quot;headerlink&quot; title=&quot;redis&quot;&gt;&lt;/a&gt;redis&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;set key val nx ex&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;优点：实现简单，性能好&lt;/l
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="方案总结" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>高并发常见方案</title>
    <link href="http://yoursite.com/2020/05/12/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    <id>http://yoursite.com/2020/05/12/%E9%AB%98%E5%B9%B6%E5%8F%91/</id>
    <published>2020-05-12T13:29:38.000Z</published>
    <updated>2020-05-12T13:29:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="高并发写"><a href="#高并发写" class="headerlink" title="高并发写"></a>高并发写</h3><ol><li>数据分片<ul><li>数据库分库分表</li><li>JDK concurrentHashMap实现</li><li>kafka的partition</li><li>ES的分布式索引</li></ul></li><li>任务分片（计算）<ul><li>CPU的指令流水线</li><li>Map/Reduce</li><li>Tomcat 1+N+M 网络模型：1个监听线程，N个IO线程负责对socket进行读写，M个worker对请求做逻辑处理。</li></ul></li><li>异步化：异步接口、异步IO<ul><li>短信验证码注册/登录</li><li>订单系统</li><li>广告计费系统，异步，多消息合并扣费</li><li>Kafka的Pipeline</li></ul></li><li>WAL技术<ul><li>MySQL innoDB 的 redo log</li><li>LSM树众多应用，levelDB等 </li></ul></li><li>批量<ul><li>kafka的百万qps写入:partition分片，磁盘顺序写入，批量（leader/follower之间的批量，本地client之间的批量）</li><li>mysql的group commit机制，对多事务的redo log批量flush</li></ul></li></ol><h3 id="高并发读"><a href="#高并发读" class="headerlink" title="高并发读"></a>高并发读</h3><ol><li>加缓存<ul><li>本地缓存/redis/memcached</li></ul></li><li>增加副本冗余<ul><li>MySQL master/slave</li><li>CDN 静态文件加速</li></ul></li><li>并发读<ul><li>异步RPC</li><li>冗余请求，降低失败率</li></ul></li></ol><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;高并发写&quot;&gt;&lt;a href=&quot;#高并发写&quot; class=&quot;headerlink&quot; title=&quot;高并发写&quot;&gt;&lt;/a&gt;高并发写&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;数据分片&lt;ul&gt;
&lt;li&gt;数据库分库分表&lt;/li&gt;
&lt;li&gt;JDK concurrentHashMap实现&lt;/l
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="方案总结" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>多副本一致性</title>
    <link href="http://yoursite.com/2020/05/12/%E5%A4%9A%E5%89%AF%E6%9C%AC%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>http://yoursite.com/2020/05/12/%E5%A4%9A%E5%89%AF%E6%9C%AC%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2020-05-12T03:23:33.000Z</published>
    <updated>2020-07-12T08:46:48.033Z</updated>
    
    <content type="html"><![CDATA[<h3 id="同步本质"><a href="#同步本质" class="headerlink" title="同步本质"></a>同步本质</h3><p>每台机器都把收到的请求按日志存下来，各机器的日志文件保持一致。选择存储“事件流”，而非最终状态，原因是：</p><ol><li>日志只有一种操作，append，相对简单</li></ol><h3 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h3><h4 id="1-Basic-Paxos"><a href="#1-Basic-Paxos" class="headerlink" title="1. Basic Paxos"></a>1. Basic Paxos</h4><ol><li>两个角色，Proposer 和 Acceptor，以及一个自增ID（n）</li><li>两个阶段，Propose阶段 和 Accept 阶段</li><li>Propose阶段<ol><li>proposer广播消息，id为n，prepare(n)</li><li>acceptor接收消息，如果n &gt; local N，则回复yes</li><li>proposer收到半数以上的yes，开始广播，否则id自增，重新广播</li></ol></li><li>Acctpt阶段<ol><li>proposer广播消息, accept(n, value)</li><li>acceptor接收消息，如果n &gt; loacal N，则持久化，返回yes</li><li>proposer收到半数以上的yes，则结束。否则id自增，从proposer阶段重新开始。</li></ol></li><li>两个问题<ol><li>Paxos是个不断循环的2PC，有可能陷入死循环，所谓“活锁”。比如3个node同时propose，都收到no，又同时n++，继续propose，继续no</li><li>性能：每次写入，需要两次RTT + 两次写盘。两次RTT分别是Propose/Accept阶段。这两个阶段都会持久化一些变量，需要磁盘IO。</li></ol></li><li>活锁问题<ol><li>多点写入，变为单点写入。选出一个leader，只让leader当proposer。从而减少冲突。leader选取办法，比如每个节点增加编号，使用心跳，选取编号最大的节点为leader。即使出现同一时间，多个leader，也不影响paxos的正确性，只会增大并发写冲突的概率。</li></ol></li></ol><h3 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h3><ol><li>单点写入：任一时刻，只允许一个有效的leader存在，所有的写请求，都传到leader上，然后由leader同步给超过半数的follower。</li><li>单条日志结构：term + index + content。term是leader的任期，只会单调递增；index是日志顺序编号，也是递增；</li><li>分为三个阶段，选举阶段，正常阶段，恢复阶段</li><li>选举阶段<ol><li>节点有三个状态：leader、follower、candidate。candidate是个中间状态。</li><li>当follower在一定时间收不到leader心跳时，就会随机sleep一个时间，然后变为candidate，发起选举。选举结束后，变为leader或follower。</li><li>选举算法，保证同一时间只有一个leader。<ol><li>如果选举请求里，日志的term和index比自己本地的新，则返回true，否则返回false。</li><li>candidate收到多数派返回true，则成为leader</li><li>每个节点只能投一次true，防止多个leader。因此选取出的leader不一定是最新的，但一定比大多数节点新。</li></ol></li></ol></li><li>正常阶段，复制日志<ol><li>只要超过半数的follower复制成功，就返回给客户端日志写入成功。</li><li>关键的日志一致性保证：<blockquote><ol><li>如果两个节点的日志，index和term相同，则内容一定相同。</li><li>如果index=M处的日志相同，则在M之前的日志，也一定相同。</li></ol></blockquote></li></ol></li><li>恢复阶段<ol><li>leader同步term给follower</li><li>以leader本地的日志为基准，复制给follower。这里比较特殊，如果新leader本身有未commit的日志，需要跟新的日志一起提交。避免一些特殊情况下，已commit的日志被覆盖。</li></ol></li><li>安全性保证<ol><li>leader数据是基准，leader不会从别的节点同步数据，只会是别的节点根据leader数据删除或追加自己的数据。</li><li>对于已经commit的日志，一定是commit的。对于新任leader上，前任leader未commit的日志，稍后会变为commit状态。不在新任leader上的未commit数据，会被覆盖。</li></ol></li></ol><h3 id="Zab"><a href="#Zab" class="headerlink" title="Zab"></a>Zab</h3><p>zookeeper使用的强一致性算法，同时也是单点写入，写请求都转发给leader。</p><ol><li>模型对比，复制状态机(replicated state machine, paxos/raft) vs 主备系统（primay-backup system，zab）,前者持久化的是客户端的请求序列（日志序列），另外一个持久化的是数据的状态变化。<ol><li>数据同步次数不一样，如果client执行三次x=1，后两次在主备系统里，不用触发同步。</li><li>存储状态变化，具有幂等性，而复制状态机不具备。</li></ol></li><li>zxid<ol><li>高32位，leader任期，类似raft的term</li><li>低32位，日志序列，类似raft的日志index</li></ol></li><li>三个阶段：Leader选举，BroadCast,恢复阶段</li><li>Leader选举：FLE算法<ol><li>Leader和Follower之间是双向心跳；raft里是单向</li><li>选取zxid最大的节点作为leader；和raft选取term+index最新的节点作为leader一个意思。</li></ol></li><li>broadcast阶段</li></ol><h3 id="raft-vs-zab"><a href="#raft-vs-zab" class="headerlink" title="raft vs zab"></a>raft vs zab</h3><p>参考：<a href="https://my.oschina.net/pingpangkuangmo/blog/782702" target="_blank" rel="noopener">https://my.oschina.net/pingpangkuangmo/blog/782702</a></p><ol><li>上一轮残留的数据怎么处理？</li></ol><p>首先看下上一轮次的leader在挂或者失去leader位置之前，会有哪些数据？</p><ul><li>已过半复制的日志</li><li>未过半复制的日志<br>一个日志是否被过半复制，是否被提交，这些信息是由leader才能知晓的，</li></ul><p>那么下一个leader该如何来判定这些日志呢？</p><p>下面分别来看看Raft和ZooKeeper的处理策略：</p><p>Raft：对于之前term的过半或未过半复制的日志采取的是保守的策略，全部判定为未提交，只有当当前term的日志过半了，才会顺便将之前term的日志进行提交。</p><p>ZooKeeper：采取激进的策略，对于所有过半还是未过半的日志都判定为提交，都将其应用到状态机中</p><p>Raft的保守策略更多是因为Raft在leader选举完成之后，没有同步更新过程来保持和leader一致（在可以对外服务之前的这一同步过程）。而ZooKeeper是有该过程的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;同步本质&quot;&gt;&lt;a href=&quot;#同步本质&quot; class=&quot;headerlink&quot; title=&quot;同步本质&quot;&gt;&lt;/a&gt;同步本质&lt;/h3&gt;&lt;p&gt;每台机器都把收到的请求按日志存下来，各机器的日志文件保持一致。选择存储“事件流”，而非最终状态，原因是：&lt;/p&gt;
&lt;ol&gt;

      
    
    </summary>
    
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="系统原理" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>开天辟地</title>
    <link href="http://yoursite.com/2020/05/11/%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0/"/>
    <id>http://yoursite.com/2020/05/11/%E5%BC%80%E5%A4%A9%E8%BE%9F%E5%9C%B0/</id>
    <published>2020-05-11T09:05:19.000Z</published>
    <updated>2020-05-14T03:04:18.669Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CSAPP-8.2-异常控制流2</title>
    <link href="http://yoursite.com/2016/11/28/CSAPP-8-2-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%812/"/>
    <id>http://yoursite.com/2016/11/28/CSAPP-8-2-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%812/</id>
    <published>2016-11-28T02:57:58.000Z</published>
    <updated>2016-11-28T02:57:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ol><li><p>进程是一个执行中的程序的实例。系统中的每个程序都是运行在某个进程的上下文中。上下文由程序正确运行所需的状态组成。这个状态包括，存放在存储器中的代码和数据，它的栈，通用目的寄存器内容，程序计数器，环境变量，以及打开文件描述符的集合。</p></li><li><p>每次用户向外壳（shell）运行一个可执行目标文件，shell会创建一个新的进程，然后再这个新进程的上下文中运行这个程序。应用程序也可以自己创建进程，并在创建的新进程中运行自己的代码或其他应用程序。</p></li></ol><h3 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h3><ol><li><p>进程为每个应用程序提供一个假象，好像它独占地使用系统地址空间。在一台有n位地址的机器上，地址空间是2<sup>n</sup>个可能地址的集合，0 ~ 2<sup>n</sup>-1。一般而言，和这个进程地址空间中的某个地址相关联的存储器字节，是不能被其他进程读写的。（肯定啊）从这个意义上说，这个地址空间是私有的。</p></li><li><p>地址空间的顶部（？~ 2<sup>n</sup>-1）是保留给内核的。这个部分包含内核的代码、数据、堆、栈等。</p></li></ol><h3 id="用户模式和内核模式"><a href="#用户模式和内核模式" class="headerlink" title="用户模式和内核模式"></a>用户模式和内核模式</h3><ol><li><p>通过某个控制寄存器的一个模式位（mode bit），来控制进程运行在哪个模式。</p></li><li><p>运行应用程序代码的进程初始时是在用户模式中。进程从用户模式变为内核模式的唯一方法是通过中断、故障或者陷入陷阱进行系统调用。</p></li><li><p>Linux的/proc文件系统。它允许用户模式进程访问内核数据结构的内容。/proc文件系统将许多内核数据结构的内容输出为一个用户程序可以读的文本文件的层次结构。比如/proc/cpuinfo查看cpu类型，/proc/<process_id>/maps查看进程使用的存储器段。</p></li></ol><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><ol><li><p>发生时机</p><ul><li><p>当程序切换到内核模式执行系统调用时，可能发生。如果系统调用因为某个等待的时间发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。比如，一个read系统调用请求一个磁盘访问，内核可以选择执行上下文切换，运行另一个进程，而不是等待数据从磁盘到达。另一个示例是sleep系统调用，它显式的请求让调用进程休眠。</p></li><li><p>中断也可能引发上下文切换。每次发生定时器中断时，内核就判定当前进程已经运行了足够长的时间，并切换到一个新的进程。<br><img src="/images/csapp-8.2-1.jpeg" alt="上下文切换"></p></li></ul></li><li><p>中断处理程序/上下文切换 污染高速缓存<br><br>中断处理程序如果访问了足够多的表项，那么再切换回应用程序时，缓存是冷的。上下文切换也会出现同样的情况。（那怎么办？）</p></li></ol><h2 id="系统调用错误处理"><a href="#系统调用错误处理" class="headerlink" title="系统调用错误处理"></a>系统调用错误处理</h2><p>当Unix系统级函数遇到错误时，它们会典型地返回-1，并设置全局整数变量errno来表示出了什么错。可以用<br>strerror(errno)来返回errno此时相关联的错误。</p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="进程ID"><a href="#进程ID" class="headerlink" title="进程ID"></a>进程ID</h3><ul><li><p>每个进程都有一个唯一的正数ID，称为PID。</p></li><li><p>可以用getpid()来获取。getppid()可以返回它父进程的PID。</p></li></ul><h3 id="创建、终止进程。"><a href="#创建、终止进程。" class="headerlink" title="创建、终止进程。"></a>创建、终止进程。</h3><ol><li><p>相同、独立的地址空间。父子进程拥有相同的用户栈、相同的本地变量值、相同的堆、相同的全局变量值、以及相同的代码。子进程得到与父进程用户级虚拟地址空间相同，但是独立的一份拷贝。包括文本、数据和bss段、堆以及用户栈。对比一下第七章讲的进程存储器映像，除下内核地址空间和共享库，其他都拷贝了。</p></li><li><p>子进程还获得和父进程任何打开的文件描述符相同的拷贝。这就意味着调用fork后，子进程可以读写fork之前父进程打开的任何文件。</p></li><li><p>阻塞，进程的执行被暂时挂起（suspend）。当收到SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOU信号时，进程就会阻塞挂起，直到它收到一个SIGCONT信号才会继续。信号是一种软件中断的形式。</p></li><li><p>终止，进程永远停止。进程会因为三种原因终止：</p><ul><li><p>收到一个信号，信号的默认行为是终止进程。（比如: kill -9）</p></li><li><p>从主程序（main）返回</p></li><li><p>调用exit函数。exit函数以status退出状态来终止进程（另一种设置退出状态的是从主程序返回一个数值）</p></li></ul></li></ol><h3 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h3><h4 id="僵死进程"><a href="#僵死进程" class="headerlink" title="僵死进程"></a>僵死进程</h4><ol><li><p>当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程会保持在一种已终止的状态中，知道被它的父进程回收。当父进程回收已终止的子进程时，内核将子进程的退出状态（上一小节说的exit status？）传递给父进程，然后抛弃已终止的进程，从此时开始，该进程就不存在了。一个终止了，但还未被回收的进程称为僵死进程。</p></li><li><p>如果父进程没有回收它自己的僵死子进程就终止了，那么内核会安排init进程来回收它们。init进程PID为1，并且是由系统初始化时内核创建的。</p></li></ol><h4 id="等待子进程结束"><a href="#等待子进程结束" class="headerlink" title="等待子进程结束"></a>等待子进程结束</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> wait(<span class="keyword">int</span> *status) ，相当于调用waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> secs)</span></span>;</span><br></pre></td></tr></table></figure><p>如果请求的时间量到了，sleep返回0，否则返回还剩下的要休眠的秒数。后一种情况，可能发生在sleep函数被一个信号中断而提前返回的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>pause()函数使调用者休眠，直到该进程收到一个信号。</p><h3 id="加载并运行程序，execve"><a href="#加载并运行程序，execve" class="headerlink" title="加载并运行程序，execve"></a>加载并运行程序，execve</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *argv[], <span class="keyword">const</span> <span class="keyword">char</span> *envp[])</span></span>;</span><br></pre></td></tr></table></figure><p>execve函数加载并运行可执行文件filename，且带参数列表argv和环境变量列表envp。execve调用一次从不返回，除非出现错误。main函数也是三个参数，不过envp是隐藏的默认参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *envp[])</span></span>;</span><br></pre></td></tr></table></figure><p><img src="/images/csapp-8.2-2.jpeg" alt="用户栈典型结构"></p><p>用户栈典型结构，注意啦，复习下进程的存储器映像，栈是从高地址向地地址分配，所以栈底的地址比栈顶大。argv和envp，都是以一个null元素结尾，因此即使不知道argv和envp的长度，也可以依次打印出来，而避免越界。</p><p>几个操作envp的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *newvalue, <span class="keyword">int</span> overwrite)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="fork和execve"><a href="#fork和execve" class="headerlink" title="fork和execve"></a>fork和execve</h3><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>fork函数在新的子进程中运行相同的程序，新的子进程时父进程的一个复制品。execve函数在当前进程的上下文中运行一个新的程序。它会覆盖当前进程的地址空间，但是并没有创建一个新进程。新的程序仍然有相同的PID，并且继承了调用execve函数时，已打开的所有文件描述符。</p><h4 id="利用fork和execve运行程序"><a href="#利用fork和execve运行程序" class="headerlink" title="利用fork和execve运行程序"></a>利用fork和execve运行程序</h4><p>shell进程就是这样来执行命令。简单版如下，再结合waitpid就可以实现相应的后台执行等功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（pid = fork() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s: Command not found.\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;进程是一个执行中的程序的实例。系统中的每个程序都是运行在某个进程的上下文中。上下文由程序正确运行所需的状态组成。这个状态包
      
    
    </summary>
    
    
      <category term="系统原理" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
      <category term="CSAPP" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/CSAPP/"/>
    
    
      <category term="CSAPP" scheme="http://yoursite.com/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP-8.3-异常控制流3</title>
    <link href="http://yoursite.com/2016/11/28/CSAPP-8-3-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%813/"/>
    <id>http://yoursite.com/2016/11/28/CSAPP-8-3-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%813/</id>
    <published>2016-11-28T02:57:58.000Z</published>
    <updated>2016-11-28T02:57:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><img src="/images/csapp-8.3-1.jpeg" alt="这里写图片描述"></p><p>每种信号类型都对应某种系统事件。底层的硬件异常是由内核异常处理程序处理的，正常情况下，堆用户进程而言是不可见的。信号提供了一种机制，统治用户进程发生了这些异常。当一个子进程终止或者停止时，内核会发送一个SIGCHLD信号给父进程。</p><h3 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h3><ol><li><p>内核更新目的进程上下文中的某个状态，来给目的进程发送信号。一个进程可以给它自己发信号。向进程发信号都是基于进程组（process group）的概念。</p></li><li><p>进程组。每个进程都只属于一个进程组，进程组由一个正整数<strong>进程组ID, pgid</strong>标识。shell也为每个作业（job）都创建一个独立的进程组，pgid是新进程的pid。如果这个新进程再继续创建子进程，默认地，一个子进程和它的父进程同属于一个进程组。一个进程可以通过函数改变自己活其他进程的进程组。（权限？）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="keyword">void</span>)</span></span>;   <span class="comment">//返回调用进程的进程组ID</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pit_t</span> pgid)</span></span>;    <span class="comment">//设置一个进程的进程组id，成功返回0，失败-1.</span></span><br></pre></td></tr></table></figure></li><li><p>kill命令可以给其他进程发送任意的信号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kill -9 1234          //给进程1234发送信号9（SIGKILL）</span><br><span class="line">kill -9 -1234         //负的pid，表示给1234这个进程组，的每个进程发信号9</span><br><span class="line">kill -9 0             //0，给当前进程所在进程组，的每个进程发信号9</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 进程可以调用kill函数发送信号，包括给他们自己 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调用alarm函数可以给它自己发送SIGALRM信号 */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h3><ol><li><p>接收信号。内核为每个进程在pending位向量维护着待处理信号的集合，而在blocked位向量中维护着被阻塞的信号集合。所以在任何时刻一种类型的信号只会被接收一次，在处理它的时候，会先把该类型的信号block。进程可以忽略信号，也可以捕获这个信号，执行信号处理程序。</p></li><li><p>当内核从一个异常处理程序返回（进程调度也属于一种异常？定时器中断？），准备把控制传递给某个进程p时，它会检查进程p的未被阻塞的待处理信号集合（pending &amp; ~blocked）。如果这个集合不为空，那么内核选择集合中的某个信号k（通常是编号最小的信号，所以Linux信号编号还是特意的呢，编号越小，优先级越高），并进入k的处理程序。</p><p>Ps:在block的时候，来的信号会不会标记到pending里？</p><p>答案：会的。执行信号的处理动作称为信号递达（Delivery），信号从产生到递达之间的状态，称为信号未决（Pending）。进程可以选择阻塞（Block）某个信号。<strong>被阻塞的信号在产生时将保持在未决状态</strong>，直到进程解除对此信号的阻塞，才执行递达的动作。注意，阻塞和忽略是不同的，只要信号被阻塞就不会递达，而忽略是在递达之后可选的一种处理动作。忽略也可以说是信号处理程序的一种。</p></li><li><p>信号的默认处理程序是如下中的一种：</p><ul><li><p>进程终止</p></li><li><p>进程终止并转储存储器（dump core）</p></li><li><p>进程暂停，直到被SIGCONT信号重启</p></li><li><p>进程忽略该信号</p></li></ul></li><li><p>修改信号的默认处理程序（忽略，恢复默认行为，自定义）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>待处理信号被阻塞。Unix信号处理程序通常会阻塞当前处理程序正在处理的类型的信号。比如正在执行SIGINT处理程序时，如果再来一个SIGINT信号，只会在pending里置1（感觉此时应该已经为1了）。</p></li><li><p>系统调用可以被中断。像read、wait和accept这样的系统调用会潜在地阻塞进程一段时间，称为慢速系统调用。在某些操作系统中，若正在执行慢速系统调用的时候收到了信号，当从信号处理程序返回时，原来的慢速系统调用可能不会继续，然而由于被信号中断，系统调用的任务并未完成。Linux系统会自动重启被中断的系统调用。</p></li><li><p>阻塞和取消阻塞信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 改变blocked向量的值，若oldset!=null，会用来保存以前blocked向量的值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化set为空集 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化set全为1，每个信号都填入blocked向量 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(sigset *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加、删除signum到set */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set中对应signum是否置1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h2><p>C语言提供了一种用户级异常控制流形式，称为非本地跳转（nonlocal jump)。它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回序列。涉及到的两个函数分别是setjmp和longjmp。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="keyword">int</span> savesigs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> retval)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siglongjmp</span><span class="params">(sigjmp_buf env, <span class="keyword">int</span> retval)</span></span>;</span><br></pre></td></tr></table></figure><ol><li><p>setjmp函数在env缓冲区中保存当前的调用环境，以供后面longjmp使用，并返回0，调用环境包括程序计数器、栈指针和通用目的寄存器。</p></li><li><p>longjmp函数从env缓冲区中恢复调用环境，然后从最近一次setjmp的env中恢复，恢复的时候相当于setjmp函数的返回，只是返回值非0（longjmp的第二个参数）。longjmp函数只有调用，没有返回。此外，setjmp函数调用一次，可以返回多次。</p></li><li><p>非本地跳转的一个重要应用是允许从一个深层嵌套的函数调用中立即返回。如果再一个深层嵌套的函数中发现了错误，可以调用longjmp(env, ret)，直接返回到setjmp处，然后根据返回的ret值判断是什么错误，调用什么样的错误处理程序。类似java的try…catch语句。</p></li></ol><h2 id="操作进程的工具"><a href="#操作进程的工具" class="headerlink" title="操作进程的工具"></a>操作进程的工具</h2><ol><li><p>strace: 打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。</p></li><li><p>pmap: 显示进程的存储器映射</p></li><li><p>/proc：一个虚拟文件系统，以ASCII文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容。比如 cat /proc/loadavg，观察linux系统上当前的平均负载。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;信号&quot;&gt;&lt;a href=&quot;#信号&quot; class=&quot;headerlink&quot; title=&quot;信号&quot;&gt;&lt;/a&gt;信号&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;&lt;im
      
    
    </summary>
    
    
      <category term="系统原理" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
      <category term="CSAPP" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/CSAPP/"/>
    
    
      <category term="CSAPP" scheme="http://yoursite.com/tags/CSAPP/"/>
    
  </entry>
  
</feed>
