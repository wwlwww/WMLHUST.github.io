---
title: 各种树结构
tags: [数据结构]
categories: [数据结构]
comments: true
date: 2020-05-13 10:21:07
updated: 2020-05-13 10:21:07
---

### B树 vs B+树 vs B*树
1. B树，B是指发明人的名字
    - 平衡多路搜索树
    - 保持键值有序，以顺序遍历
    - 使用不完全填充的节点块，来加速插入和删除
    - 节点块至少半满，提升空间利用率

2. B+树 VS B树
    - 非叶子节点，只保存索引：从而可以减少索引树的大小，内存里可以保存更多的索引。由于每次都需要走到叶子节点，查询时间也更稳定。
    - 叶子节点之间，增加链指针，方便遍历

3. B*树
在B+树的基础上
    - 非根和非叶子节点，增加指向兄弟的指针
    - 插入时，如果节点已满，会检查兄弟节点是否满，未满，则向兄弟节点转移数据；已满，则从当前节点和兄弟节点，各拿出1/3数据，创建一个新节点。  
从而节点空间利用率更高，节点分裂的情况也减少。

### 红黑树
1. 也是一种BST(二叉搜索树)，但是不要求完全平衡
2. 牺牲部分平衡性，达到较快的插入和删除性能
3. 使用场景：linux CFS调度，nginx timer等
4. vs B树: B树作为多路搜索，能够在树深较小的情况下，支持更多的数据节点。对于磁盘类操作，可以避免大量的随机IO（一个磁盘page，可以读取到更多的索引，类似MySQL），从而优化读写性能。而红黑树一般整棵树都在内存里，不涉及到磁盘操作，支持的数据量较小，但是由于各种操作优于BST，因此常用于涉及到排序、搜索的场景。比如CFS，为了保证公平调度，每次选取当前执行总时间最小的线程执行。

### LSM，Log-Structured Merged Tree
1. 核心思想：**放弃部分读性能，提高写性能。** 适用于kv存储。

2. 内存中的memtable，磁盘上的sstable。读取的时候，需要遍历sstable，这里的 优化是，使用是bloom filter，确定一个Key是否在sstable里。

2. 一般LSM-Trees会配合内存排序，内存里将写数据缓冲（通常是一个红黑树、跳表之类的结构）。等积累得足够多之后，使用归并排序将数据合并，写入磁盘。

1. 应用：rocksDB，levelDB，hbase
   - rocksDB：c++编写的kv存储引擎，基于levelDB改造
   - levelDB：kv存储引擎
   - hbase: 分布式存储，列数据库，应对大量数据（亿级以上）   

    这些思想类似lsm，但也有一些优化和改进，比如levelDB为了避免sstable过多，以及降低sstable合并过程中的开销，增加了level的概念。如果没有level，新sstable需要和旧的sstable比较，随着数据量的增多，新sstable需要和越来越多的sstable合并，从而效率降低。（如果每次合并后只留下一个大的sstable，效率一样会降低，因为涉及到插入操作。）有了level，上下层level，待比较的相关sstable数量将会得到控制。从而加快压缩、合并的过程。  
    除下按分层合并，还有按大小合并，hbase使用该种方法。两种思想，一种是更新的和更老的合并，一种是更小的和更大的合并。

    sstable会保存所有写入的值（K-V），新的value并不会覆盖旧的value，而是读取的时候，从新的segment开始找，找到就停下。压缩、合并的过程，就是保留新的value，去除旧的value的过程。   
    另外，为了防止系统崩溃，数据丢失，也会使用额外的WAL日志。相当于每次写入，需要更新有序的memtable，以及append WAL日志。   
    
    Lucene(ES的索引引擎)，也是用了类似的思想存储它的倒排索引。首先根据类lsm思想找到单词对应的倒排索引值（文档ID列表），再根据文档ID，获取具体的文档。

3. 参考资料
   - http://blog.fatedier.com/2016/06/15/learn-lsm-tree/

### lsm vs b+树
1. 查询过程  
为了快速查询，一个办法是建立hash索引，但是hash索引占用空间太大，而且不支持区间查询。另一个办法是，事先对数据进行排序，B+树，把排序的操作放在了写入的时候，读的时候便轻松一些。   

2. 写过程  
    但是B树面对高并发写的时候，压力很大。B树把所有的压力都放到了写操作的时候，从根节点索引到数据存储的位置，可能需要多次读文件；真正插入的时候，又可能会引起page的分裂，多次写文件。   

    LSM在写的时候，直接写入内存，然后利用红黑树保持内存中的数据有序，由后台线程定期或被触发，去merge和持久化到磁盘。也会使用WAL方式记录log，避免数据丢失。  
    
    当写比读多时，LSM树相比于B树有更好的性能。因为随着insert操作，为了维护B树结构，节点分裂。读磁盘的随机读写概率会变大，性能会逐渐减弱。LSM把多次IO，批量变成一次IO，复用了磁盘寻道时间，极大提升效率。

3. 总结下，通常LSM树的写入更快，B树的读取速度更快。